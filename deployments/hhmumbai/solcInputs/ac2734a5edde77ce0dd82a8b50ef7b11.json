{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/metatx/MinimalForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/cryptography/ECDSA.sol\";\nimport \"../utils/cryptography/draft-EIP712.sol\";\n\n/**\n * @dev Simple minimal forwarder to be used together with an ERC2771 compatible contract. See {ERC2771Context}.\n */\ncontract MinimalForwarder is EIP712 {\n    using ECDSA for bytes32;\n\n    struct ForwardRequest {\n        address from;\n        address to;\n        uint256 value;\n        uint256 gas;\n        uint256 nonce;\n        bytes data;\n    }\n\n    bytes32 private constant _TYPEHASH =\n        keccak256(\"ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,bytes data)\");\n\n    mapping(address => uint256) private _nonces;\n\n    constructor() EIP712(\"MinimalForwarder\", \"0.0.1\") {}\n\n    function getNonce(address from) public view returns (uint256) {\n        return _nonces[from];\n    }\n\n    function verify(ForwardRequest calldata req, bytes calldata signature) public view returns (bool) {\n        address signer = _hashTypedDataV4(\n            keccak256(abi.encode(_TYPEHASH, req.from, req.to, req.value, req.gas, req.nonce, keccak256(req.data)))\n        ).recover(signature);\n        return _nonces[req.from] == req.nonce && signer == req.from;\n    }\n\n    function execute(ForwardRequest calldata req, bytes calldata signature)\n        public\n        payable\n        returns (bool, bytes memory)\n    {\n        require(verify(req, signature), \"MinimalForwarder: signature does not match request\");\n        _nonces[req.from] = req.nonce + 1;\n\n        (bool success, bytes memory returndata) = req.to.call{gas: req.gas, value: req.value}(\n            abi.encodePacked(req.data, req.from)\n        );\n        // Validate that the relayer has sent enough gas for the call.\n        // See https://ronan.eth.link/blog/ethereum-gas-dangers/\n        assert(gasleft() > req.gas / 63);\n\n        return (success, returndata);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC721 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC721Pausable is ERC721, Pausable {\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        require(!paused(), \"ERC721Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/core/EscrowERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../utils/ZbyteContext.sol\";\nimport \"../interface/relay/IRelayWrapper.sol\";\nimport \"../interface/core/IEscrowERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title The ERC20 Escrow contract\n/// @dev DPLAT ERC20 escrow abstract contract\nabstract contract EscrowERC20 is ZbyteContext, IEscrowERC20, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @notice Total vERC20 supply on all chains\n    uint256 private _totalSupply;\n    // @notice mapping of vERC20 amount for the chain\n    mapping(uint256 => uint256) private _reserve;\n    /// @notice mapping of the vERC20 contract address for the chain\n    mapping(uint256 => address) public vERC20Addresses;\n    /// @notice The underlying ERC20 token contract\n    IERC20 public ulAsset;\n    /// @notice Authorized workers\n    mapping(address => bool) authorizedWorkers;\n    /// @notice RelayWrapper contract address\n    /// @dev Escrow can only use this trusted RelayWrapper to perform deposit/withdraw\n    IRelayWrapper public relayWrapper;\n    /// @notice nonce used for deposit/withdraw operations.  Incremented for every successful deposit or withdraw\n    uint256 nonce;\n    /// @notice enumeration of actions performed on this escrow\n    enum Action {\n        NONE,\n        DEPOSIT,\n        WITHDRAW\n    }\n    /// @notice Parameters of the deposit/withdraw operation.\n    struct PendingAction {\n        Action action;\n        address nAddress;\n        address rAddress;\n        uint256 chainId;\n        uint256 amount;\n    }\n    /// @notice mapping of current deposit/withdraw operations for which callback has not yet been received\n    /// @dev action: EscrowERC20.Action that is being performed\\\n    ///   nAddress: Address from which ERC20 tokens are deposited (for Action.DEPOSIT) or tokens are received into (for Action.WITHDRAW)\\\n    ///   rAddress: Address to which vERC20 tokens are deposited (for Action.DEPOSIT) or tokens are received into (for Action.WITHDRAW)\\\n    ///   chainId: chain id of the remote chain\\\n    ///   amount: Amount of tokens that are deposited or withdrawn\\\n    /// @dev This is updated on successful deposit/withdraw and cleared when callback is received\n    mapping(bytes32 => PendingAction) public pendingAction;\n\n    /// @notice ZBYT ERC20 Escrow constructor\n    /// @param forwarder_ Forwarder contact address\n    /// @param asset_ Underlying ERC20 asset address\n    constructor(address forwarder_, IERC20 asset_) {\n        if (address(asset_) == address(0)) {\n            revert ZeroAddress();\n        }\n        if(forwarder_ == address(0)) {\n            revert ZeroAddress();\n        }\n        _setTrustedForwarder(forwarder_);\n        ulAsset = asset_;\n    }\n\n    /// @notice receive function\n    receive() external payable {\n        revert CannotSendEther();\n    }\n\n\n    /**\n    * @dev Modifier to ensure that the sender is an authorized worker.\n    * @notice Reverts the transaction with an `UnAuthorized` error if the sender is not authorized.\n    */\n    modifier onlyAuthorized() {\n        if (!authorizedWorkers[_msgSender()]) {\n            revert UnAuthorized(_msgSender());\n        }\n        _;\n    }\n\n    /// @notice Modifier to enforce call only from valid relay contract\n    modifier onlyRelay {\n        if(!(relayWrapper.isValidRelay(block.chainid,_msgSender()))) {\n            revert InvalidRelay(_msgSender());\n        }\n        _;\n    }\n\n    /// @notice Registers or unregisters a worker, allowing or denying access to specific functionality.\n    /// @param worker_ The address of the worker to be registered or unregistered.\n    /// @param register_ A boolean indicating whether to register (true) or unregister (false) the worker.\n    function registerWorker(address worker_, bool register_) public onlyOwner {\n        authorizedWorkers[worker_] = register_;\n        emit WorkerRegistered(worker_, register_);\n    }\n\n\n    /// @notice Get the latest nonce \n    /// @dev nonce is incremented for every successful deposit or withdraw\n    function getNonce() public view returns(uint256) {\n        return nonce;\n    }\n\n    /// @notice Set the address of vERC20 on a given chain\n    /// @param verc20_ vERC20 contract address\n    /// @param chain_ chain id of the chain where vERC2o contract resides\n    /// @dev nonce is incremented for every successful deposit or withdraw\n    function _setvERC20Address(address verc20_, uint256 chain_) internal {\n        if (verc20_ == address(0)) {\n            revert ZeroAddress();\n        }\n        if(chain_ == 0) {\n            revert ZeroValue();\n        }\n        vERC20Addresses[chain_] = verc20_;\n\n        emit vERC20AddressSet(verc20_,chain_);\n    }\n\n    /// @notice Set the address of core relay wrapper\n    /// @param wrapper_ Core relay wrapper contract address\n    function _setRelayWrapperAddress(address wrapper_) internal {\n        if (wrapper_ == address(0)) {\n            revert ZeroAddress();\n        }\n        relayWrapper = IRelayWrapper(wrapper_);\n\n        emit RelayWrapperAddressSet(wrapper_);\n    }\n\n    /// @notice Return the amount of vERC20 currently available on all chains\n    function totalSupplyAllChains() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @notice Return the amount of vERC20 currently available on a given chain\n    /// @param chain_ The id of the chain of interest\n    function totalSupply(uint256 chain_) public view virtual override  returns (uint256) {\n        return _reserve[chain_];\n    }\n\n    /// @notice Return the address of underlying ERC20 contract address\n    function asset() external view virtual override returns (address) {\n        return address(ulAsset);\n    }\n\n    /// @notice Record and update state on successful deposit/withdraw \n    /// @param action_ deposit or withdraw action\n    /// @param amount_ amount of tokens deposited or withdrawn\n    /// @param chain_ target chain id\n    function _record(Action action_, uint256 amount_, uint256 chain_) internal {\n        if (action_ == Action.DEPOSIT) {\n            _totalSupply += amount_;\n            _reserve[chain_] += amount_;\n        } else if (action_ == Action.WITHDRAW){\n            _totalSupply -= amount_;\n            _reserve[chain_] -= amount_;\n        }\n     }\n\n    /// @notice Deposit ERC20 tokens to obtain vERC20 on target chain\n    /// @notice Deposit with ZbyteRelay is supported only via Zbyte Platform in case user deposits directly, it may result in loss of funds(Zbyte).\n    /// @param relay_ Relay identifier that should be used for the crosschain call\n    /// @param chain_ Target chain identifier\n    /// @param receiver_ Recipient address for vERC20\n    /// @param cost_ Cost of the operation\n    /// @param amount_ Amount of ERC20 deposited\n    function _deposit(uint256 relay_,\n                      uint256 chain_,\n                      address receiver_,\n                      uint256 cost_,\n                      uint256 amount_)\n                      internal\n                      nonReentrant\n                      returns (bool result) {\n        address verc20_ = vERC20Addresses[chain_];\n        _beforeTokenDeposit(relay_, chain_, receiver_, amount_, verc20_);\n        IERC20(ulAsset).safeTransferFrom(_msgSender(), _getTrustedForwarder(), cost_);\n        IERC20(ulAsset).safeTransferFrom(_msgSender(), address(this), amount_);\n\n        bytes32 _ack = keccak256(abi.encodePacked(chain_,receiver_,amount_, nonce));\n        nonce = nonce + 1;\n        PendingAction memory pAction;\n        pAction.action = Action.DEPOSIT;\n        pAction.nAddress = _msgSender();\n        pAction.rAddress = receiver_;\n        pAction.chainId = chain_;\n        pAction.amount = amount_;\n        pendingAction[_ack] = pAction;\n        result = relayWrapper.performCrossChainCall(relay_,\n                                block.chainid,\n                                chain_,\n                                verc20_,\n                                abi.encodeWithSignature(\"mint(address,uint256)\",receiver_,amount_),\n                                _ack,\n                                address(this),\n                                \"\");\n        require(result, \"_deposit: callRemote failed.\");\n\n        _afterTokenDeposit(relay_, chain_, receiver_, amount_, verc20_);\n\n        emit ERC20Deposited(_msgSender(), receiver_, amount_, chain_,_ack);\n        return result;\n    }\n\n    /// @notice Withdraw ERC20 tokens by depositing vERC20 on target chain\n    /// @param relay_ Relay identifier that should be used for the crosschain call\n    /// @param chain_ Target chain identifier\n    /// @param vERC20Depositor_ Address to deposit vERC20\n    /// @param receiver_ Recipient address for ERC20\n    /// @dev The paymaster_ should be a valid paymaster (e.g., forwarder). All vERC20 held by paymaster is destroyed and equal ERC20 is deposited\n    function _withdraw(uint256 relay_,\n                      uint256 chain_,\n                      address vERC20Depositor_,\n                      address receiver_)\n                      internal\n                      nonReentrant\n                      returns (bool result) {\n        address verc20_ = vERC20Addresses[chain_];\n        _beforeTokenWithdraw(relay_, chain_, vERC20Depositor_, receiver_, verc20_);\n\n        bytes32 _ack = keccak256(abi.encodePacked(chain_,vERC20Depositor_,receiver_,nonce));\n        nonce = nonce + 1;\n        PendingAction memory pAction;\n        pAction.action = Action.WITHDRAW;\n        pAction.nAddress = receiver_;\n        pAction.rAddress = vERC20Depositor_;\n        pAction.chainId = chain_;\n        pAction.amount = 0;\n        pendingAction[_ack] = pAction;\n        result = relayWrapper.performCrossChainCall(relay_,\n                                block.chainid,\n                                chain_,\n                                verc20_,\n                                abi.encodeWithSignature(\"destroy(address)\",vERC20Depositor_),\n                                _ack,\n                                address(this),\n                                \"\");\n\n        require(result, \"_withdraw: callRemote failed.\");\n        \n        _afterTokenWithdraw(relay_, chain_, vERC20Depositor_, receiver_, verc20_);\n\n        emit ERC20Withdrawn(_msgSender(), vERC20Depositor_, receiver_, chain_, _ack);\n        return result;\n    }\n\n    /// @notice callback handler to handle acknowledgement for deposit/withdraw\n    /// @param chain_ Target chain identifier\n    /// @param ack_ Unique hash of the submitted deposit/withdraw request\n    /// @param success_ true if the deposit/withdraw was successful on remote\n    /// @param retval_ The amount of tokens that were deposited/withdrawn\n    function _callbackHandler(uint256 chain_,\n                            bytes32 ack_,\n                            bool success_,\n                            uint256  retval_)\n        internal\n        onlyRelay returns(uint256) {\n        PendingAction storage _pAction = pendingAction[ack_];\n        address _nAddress = _pAction.nAddress;\n        uint256 _amount = _pAction.amount;\n        uint256 _chainId = _pAction.chainId;\n\n        if (_pAction.action == Action.DEPOSIT) {\n            if ((chain_ != _chainId) || (_amount != retval_)) {\n                revert InvalidCallbackMessage(_chainId, _amount, chain_, retval_);\n            }\n            if(success_) {\n                _record(Action.DEPOSIT, _amount, _chainId);\n                emit ERC20DepositConfirmed(ack_, success_,retval_);\n            } else {\n                IERC20(ulAsset).safeTransfer(_nAddress, _amount);\n                emit ERC20DepositFailedAndRefunded(ack_, success_,retval_);\n            }\n            delete pendingAction[ack_];\n        } else if (_pAction.action == Action.WITHDRAW) {\n            if (chain_ != _chainId) {\n                revert InvalidCallbackMessage(_chainId, _amount, chain_, retval_);\n            }\n\n            if (success_) {\n                IERC20(ulAsset).safeTransfer(_nAddress, retval_);\n                _record(Action.WITHDRAW, _amount, _chainId);\n                emit ERC20WithdrawConfirmed(ack_, success_,retval_);\n            } else {\n                emit ERC20WithdrawFailed(ack_, success_, retval_);\n            }\n            delete pendingAction[ack_];\n\n        } else {\n            revert InvalidCallbackAck(chain_,ack_, success_,retval_);\n        }\n        return 0;\n    }\n\n    /// @notice Hook called before token deposit\n    /// @param relay_ Relay identifier that should be used for the crosschain call\n    /// @param chain_ Target chain identifier\n    /// @param receiver_ Recipient address for vERC20\n    /// @param amount_ Amount of ERC20 deposited\n    /// @param verc20_ vERC20 contract address on target chain\n    function _beforeTokenDeposit(uint256 relay_,\n                      uint256 chain_,\n                      address receiver_,\n                      uint256 amount_,\n                      address verc20_) internal  {}\n\n    /// @notice Hook called after token deposit\n    /// @param relay_ Relay identifier that should be used for the crosschain call\n    /// @param chain_ Target chain identifier\n    /// @param receiver_ Recipient address for vERC20\n    /// @param amount_ Amount of ERC20 deposited\n    /// @param verc20_ vERC20 contract address on target chain\n    function _afterTokenDeposit(uint256 relay_,\n                      uint256 chain_,\n                      address receiver_,\n                      uint256 amount_,\n                      address verc20_) internal  {}\n\n    /// @notice Hook called before token withdraw\n    /// @param relay_ Relay identifier that should be used for the crosschain call\n    /// @param chain_ Target chain identifier\n    /// @param paymaster_ Paymaster address to deposit vERC20\n    /// @param receiver_ Recipient address for ERC20\n    /// @param verc20_ vERC20 contract address on target chain\n    function _beforeTokenWithdraw(uint256 relay_,\n                      uint256 chain_,\n                      address paymaster_,\n                      address receiver_,\n                      address verc20_) internal  {}\n\n    /// @notice Hook called after token withdraw\n    /// @param relay_ Relay identifier that should be used for the crosschain call\n    /// @param chain_ Target chain identifier\n    /// @param paymaster_ Paymaster address to deposit vERC20\n    /// @param receiver_ Recipient address for ERC20\n    /// @param verc20_ vERC20 contract address on target chain\n    function _afterTokenWithdraw(uint256 relay_,\n                      uint256 chain_,\n                      address paymaster_,\n                      address receiver_,\n                      address verc20_) internal  {}\n}\n"
    },
    "contracts/core/ZbyteEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./EscrowERC20.sol\";\n\n/// @title The ZBYT ERC20 Escrow contract\ncontract ZbyteEscrow is Ownable, Pausable, EscrowERC20 {\n\n    constructor(address forwarder_,\n                address zbyte_)\n                EscrowERC20(forwarder_, IERC20(zbyte_)) {\n    }\n\n    /// @notice Deposit ERC20 tokens to obtain vERC20 on target chain\n    /// @param relay_ Relay identifier that should be used for the crosschain call\n    /// @param chain_ Target chain identifier\n    /// @param receiver_ Recipient address for vERC20\n    /// @param cost_ Cost of the operation\n    /// @param amount_ Amount of ERC20 deposited\n    function deposit(uint256 relay_,\n                      uint256 chain_,\n                      address receiver_,\n                      uint256 cost_,\n                      uint256 amount_)\n                      public\n                      whenNotPaused\n                      returns (bool result) {\n        return _deposit(relay_,chain_,receiver_,cost_,amount_);\n    }\n\n    /// @notice Withdraw ERC20 tokens by depositing vERC20 on target chain\n    /// @param relay_ Relay identifier that should be used for the crosschain call\n    /// @param chain_ Target chain identifier\n    /// @param vERC20Depositor_ Address to deposit vERC20\n    /// @param receiver_ Recipient address for ERC20\n    /// @dev The paymaster_ should be a valid paymaster (e.g., forwarder). All vERC20 held by paymaster is destroyed and equal ERC20 is deposited\n    function withdraw(uint256 relay_,\n                      uint256 chain_,\n                      address vERC20Depositor_,\n                      address receiver_)\n                      whenNotPaused\n                      public onlyAuthorized\n                      returns (bool result) {\n        return _withdraw(relay_,chain_,vERC20Depositor_,receiver_);\n    }\n\n    /// @notice callback handler to handle acknowledgement for deposit/withdraw\n    /// @param chain_ Target chain identifier\n    /// @param ack_ Unique hash of the submitted deposit/withdraw request\n    /// @param success_ true if the deposit/withdraw was successful on remote\n    /// @param retval_ The amount of tokens that were deposited/withdrawn\n    function callbackHandler(uint256 chain_,\n                            bytes32 ack_,\n                            bool success_,\n                            uint256  retval_)\n        external\n        returns(uint256) {\n        return _callbackHandler(chain_,ack_,success_,retval_);\n\n    }\n\n    /// @notice Set the address of vERC20 on a given chain\n    /// @param verc20_ vERC20 contract address\n    /// @param chain_ chain id of the chain where vERC2o contract resides\n    /// @dev nonce is incremented for every successful deposit or withdraw\n    function setvERC20Address(address verc20_, uint256 chain_) public onlyOwner {\n        _setvERC20Address(verc20_,chain_);\n    }\n    \n    /// @notice Set the address of core relay wrapper\n    /// @param wrapper_ Core relay wrapper contract address\n    function setRelayWrapperAddress(address wrapper_) public onlyOwner {\n        _setRelayWrapperAddress(wrapper_);\n    }\n\n    /// @notice Pauses the contract (mint, transfer and burn operations are paused)\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /// @notice Unpauses the paused contract\n    function unpause() external onlyOwner whenPaused {\n        _unpause();\n    }\n\n    /// @notice ERC2771 _msgSender override\n    function _msgSender() internal view override(ZbyteContext,Context) returns (address sender) {\n        return ZbyteContext._msgSender();\n    }\n\n    /// @notice ERC2771 _msgData override\n    function _msgData() internal view override(ZbyteContext,Context) returns (bytes calldata) {\n        return ZbyteContext._msgData();\n    }\n}"
    },
    "contracts/core/ZbyteForwarderCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/metatx/MinimalForwarder.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title The Zbyte core forwarder contract\n/// @dev The Zbyte core forwarder contract.\ncontract ZbyteForwarderCore is Ownable, MinimalForwarder, ReentrancyGuard {\n\n    // errors\n    /// @notice error (0xd92e233d): Address is address(0)\n    error ZeroAddress();\n\n    // events\n    /// @notice event (0xa6cc9cbb): DPLAT address is set\n    event ZbyteAddressSet(address);\n    /// @notice event (0x0a787863): Token forwarder address is set\n    event ZbyteTokenForwarderAddressSet(address);\n    /// @notice event (0x14229a64) Escrow address is set\n    event EscrowAddressSet(address);\n\n    // DPLAT ERC20 address\n    /// @notice DPLAT ERC20 contract address\n    address public zByteAddress;\n    /// @notice Forwarder of ERC20 token contract\n    MinimalForwarder zbyteTokenForwarder;\n    // Escrow address\n    /// @notice Escrow contract address\n    address public escrowAddress;\n\n    bytes4 private approvesig = bytes4(keccak256(\"approve(address,uint256)\"));\n    bytes4 private depositsig = bytes4(keccak256(\"deposit(uint256,uint256,address,uint256,uint256)\"));\n\n\n    /// @notice Set DPLAT ERC20 address\n    /// @param zbyte_ DPLAT ERC20 contact address\n    function setZbyteAddress(address zbyte_) public onlyOwner {\n        if(zbyte_ == address(0)) {\n            revert ZeroAddress();\n        }\n        zByteAddress = zbyte_;\n\n        emit ZbyteAddressSet(zbyte_);\n    }\n\n    /// @notice Set DPLAT ERC20 Forwarder address\n    /// @param forwarder_ DPLAT ERC20 forwarder contact address\n    function setZbyteTokenForwarderAddress(address forwarder_) public onlyOwner {\n        if(forwarder_ == address(0)) {\n            revert ZeroAddress();\n        }\n        zbyteTokenForwarder = MinimalForwarder(forwarder_);\n\n        emit ZbyteTokenForwarderAddressSet(forwarder_);\n    }\n\n    /// @notice Set Zbyte Escrow address\n    /// @param escrow_ Zbyte Escrow contract address\n    function setEscrowAddress(address escrow_) public onlyOwner {\n        if(escrow_ == address(0)) {\n            revert ZeroAddress();\n        }\n        escrowAddress = escrow_;\n\n        emit EscrowAddressSet(escrow_);\n    }\n\n    /// @notice Perform approve and depost of Zbyte in single call\n    /// @param reqApprove_ ForwardRequest for the approve call\n    /// @param signatureApprove_ Signature of the approve call params\n    /// @param reqDeposit_ ForwardRequest for the deposit call\n    /// @param signatureDeposit_ Signature of the deposit call params\n    /// @return success returns true of approve and deposit are successful\n    /// @dev Allows gasless approve+deposit of DPLAT token to be used at https://dplat.zbyte.io\n    function approveAndDeposit(ForwardRequest calldata reqApprove_, bytes calldata signatureApprove_,\n                     ForwardRequest calldata reqDeposit_, bytes calldata signatureDeposit_)\n        public\n        payable\n        nonReentrant\n        returns (bool success)\n    {\n        bytes memory _returndata;\n        require(reqApprove_.from == reqDeposit_.from, \"approveAndDeposit: Invalid from addresses\");\n        require(reqApprove_.to == address(zByteAddress)\n                && bytes4(reqApprove_.data[:4]) == approvesig\n                && address(bytes20(reqApprove_.data[16:36])) == escrowAddress, \"approveAndDeposit: Invalid approve data\");\n        require(reqDeposit_.to == address(escrowAddress)\n                && bytes4(reqDeposit_.data[:4]) == depositsig, \"approveAndDeposit: Invalid deposit data\");\n\n        (success, _returndata) = zbyteTokenForwarder.execute(reqApprove_, signatureApprove_);\n        require(success,\"Approve fail\");\n        (success, _returndata) = execute(reqDeposit_, signatureDeposit_);\n        require(success, \"Deposit fail\");\n\n        return success;\n    }\n}\n"
    },
    "contracts/dplat/ZbyteDPlatDiamond/LibDPlat.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\n/// @notice Library for DPlat base storage and functions\n/// @dev Library for DPlat base storage and functions\nlibrary LibDPlatBase {\n    /// @notice To record PreExecute states \n    struct PreExecStates {\n        bytes4 enterprise;\n    }\n\n    /// @notice Diamond storage for DPlat Base struct\n    struct DiamondStorage {\n        PreExecStates preExecuteStates;\n        address zbyteVToken; \n        address zbytePriceFeeder;\n    }\n\n    /// @notice Retrieves the DiamondStorage struct for the library.\n    /// @dev zbyteVToken: The address of the ZbyteVToken\\\n    ///  zbyteValueInNativeEthGwei: The value of Zbyte in native Ether (in Gwei)\\\n    ///  zbyteBurnFactor: Burn factor, represents the percent of gas used that will be 'burnt'\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 storagePosition = keccak256(\"diamond.storage.LibDPlatBase.v1\");\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n\n    /// @notice Gets the ZbyteVToken address.\n    /// @return The address of the ZbyteVToken.\n    function _getZbyteVToken() internal view returns (address) {\n        DiamondStorage storage _dsb = diamondStorage();\n        return _dsb.zbyteVToken;\n    }\n\n    /**\n    * @dev Retrieves the address of the Zbyte price feeder from DiamondStorage.\n    * @return The address of the Zbyte price feeder.\n    */\n    function _getZbytePriceFeeder() internal view returns (address) {\n        DiamondStorage storage _dsb = diamondStorage();\n        return _dsb.zbytePriceFeeder;\n    }\n\n    /**\n    * @dev Sets the pre-execution states with the specified enterprise identifier.\n    * @param enterprise_ The enterprise identifier to be set in the pre-execution states.\n    */\n    function _setPreExecStates(bytes4 enterprise_) internal {\n        DiamondStorage storage _dsb = diamondStorage();\n        _dsb.preExecuteStates.enterprise = enterprise_;\n    }\n\n    /**\n    * @dev Retrieves the pre-execution states from DiamondStorage.\n    * @return The pre-execution states stored in DiamondStorage.\n    */\n    function _getPreExecStates() internal view returns (PreExecStates memory) {\n        DiamondStorage storage _dsb = diamondStorage();\n        return _dsb.preExecuteStates;\n    }\n\n}\n\n/// @notice Library for DPlat registration storage and functions\n/// @dev Library for DPlat registration storage and functions\nlibrary LibDPlatRegistration {\n    /// @notice event (0x75ee1f8e): Zbyte DPlat enterprise limit is set.\n    event ZbyteDPlatEnterpriseLimitSet(bytes4,uint256,uint256);\n\n    /// @notice Diamond storage for DPlat registration struct\n    struct DiamondStorage {\n        mapping(bytes4 => address) registeredEnterprises;\n        mapping(bytes4 => address) registeredEnterprisePolicy;\n        mapping(address => bytes4) registeredDapps;\n        mapping(address => bytes4) registeredEnterpriseUsers;\n        mapping(bytes4 => uint256) enterpriseLimit;\n    }\n\n    /// @notice Retrieves the DiamondStorage struct for the library.\n    /// @dev registeredEnterprises: Mapping of registered enterprises by bytes4 ID\\\n    ///  registeredEnterprisePolicy: Mapping of enterprise policies by bytes4 ID\\\n    ///  registeredDapps: Mapping of registered Dapps by address\\\n    ///  registeredEnterpriseUsers: Mapping of registered enterprise users by address\\\n    ///  enterpriseLimit: Mapping of enterprise limits by bytes4 ID\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 storagePosition = keccak256(\"diamond.storage.LibDPlatRegistration.v1\");\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n\n    /// @notice Gets the enterprise limit for a given enterprise ID.\n    /// @param enterprise_ The enterprise ID.\n    /// @return The enterprise limit.\n    function _getEnterpriseLimit(bytes4 enterprise_) internal view returns (uint256) {\n        DiamondStorage storage _dsp = diamondStorage();\n        return _dsp.enterpriseLimit[enterprise_];\n    }\n\n    /// @notice Sets the enterprise limit for a given enterprise ID.\n    /// @param enterprise_ The enterprise ID.\n    /// @param amount_ The limit amount to set.\n    function _setEntepriseLimit(bytes4 enterprise_, uint256 amount_) internal {\n        DiamondStorage storage _dsp = diamondStorage();\n        uint256 _currentEnterpriseLimit = _dsp.enterpriseLimit[enterprise_];\n        _dsp.enterpriseLimit[enterprise_] = amount_;\n        emit ZbyteDPlatEnterpriseLimitSet(enterprise_,_currentEnterpriseLimit,amount_);\n    }\n\n    /// @notice Checks if an enterprise has a registered policy and retrieves the policy address.\n    /// @param enterprise_ The enterprise ID.\n    /// @return Enterprise payment policy address.\n    function _doesEnterpriseHavePolicy(bytes4 enterprise_) internal view returns (address) {\n        DiamondStorage storage _dsp = diamondStorage();\n        return _dsp.registeredEnterprisePolicy[enterprise_];\n    }\n\n    /// @notice Checks if the given provider is registered\n    /// @param provider_ The provider address\n    /// @return bool indicating if the provider is registered\n    function isProviderRegistered(address provider_) internal view returns(bool) {\n        LibDPlatProvider.DiamondStorage storage _dsp = LibDPlatProvider.diamondStorage();\n        return _dsp.registeredProviders[provider_];\n    }\n\n    /// @notice Checks if the given agent is registered\n    /// @param agent_ The agent address\n    /// @return returns the address of provider if registered, or address(0)\n    function isProviderAgentRegistered(address agent_) internal view returns(address) {\n        LibDPlatProvider.DiamondStorage storage _dsp = LibDPlatProvider.diamondStorage();\n        return _dsp.registeredProviderAgent[agent_];\n    }\n\n    /// @notice Checks if the given enterprise is registered\n    /// @param enterprise_ The enterprise bytes4 ID\n    /// @return returns the address of provider if registered, or address(0)\n    function isEnterpriseRegistered(bytes4 enterprise_) internal view returns(address) {\n        LibDPlatRegistration.DiamondStorage storage _dsr = LibDPlatRegistration.diamondStorage();\n        return _dsr.registeredEnterprises[enterprise_];\n    }\n\n    /// @notice Checks if the given user is registered with an enterprise\n    /// @param user_ The user address\n    /// @return returns the address of provider if registered, or address(0)\n    function isEnterpriseUserRegistered(address user_) internal view returns(bytes4) {\n        LibDPlatRegistration.DiamondStorage storage _dsr = LibDPlatRegistration.diamondStorage();\n        return _dsr.registeredEnterpriseUsers[user_];\n    }\n\n    /// @notice Checks if the given dapp (contract) is registered with an enterprise\n    /// @param dapp_ The contract address\n    /// @return returns the address of provider if registered, or address(0)\n    function isEnterpriseDappRegistered(address dapp_) internal view returns(bytes4) {\n        LibDPlatRegistration.DiamondStorage storage _dsr = LibDPlatRegistration.diamondStorage();\n        return _dsr.registeredDapps[dapp_];\n    }\n}\n\n/// @notice Library for DPlat provider storage and functions\n/// @dev Library for DPlat provider storage and functions\nlibrary LibDPlatProvider {\n\n    /// @notice Diamond storage for DPlat provider struct\n    struct DiamondStorage {\n        mapping(address => bool) registeredProviders;\n        mapping(address => address) registeredProviderAgent;\n    }\n\n    /// @notice Retrieves the DiamondStorage struct for the library.\n    /// @dev registeredProviders: Mapping of registered providers by address\\\n    ///  registeredProviderAgent: Mapping of registered provider agents by address\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 storagePosition = keccak256(\"diamond.storage.LibDPlatProvider.v1\");\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n}\n"
    },
    "contracts/dplat/ZbyteDPlatDiamond/ZbyteDPlatBaseFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\nimport \"./LibDPlat.sol\";\nimport \"../../utils/ZbyteContextDiamond.sol\";\n\n/// @title DPlat Base Facet contract\n/// @dev DPlat Base Facet contract\ncontract ZbyteDPlatBaseFacet is ZbyteContextDiamond {\n\n    // events\n    /// @notice event (0x10e1dc22): VZbyte token address is set.\n    event ZbyteVTokenAddressSet(address);\n    /// @notice event (0xa0e61546): Zbyte token value in terms of native eth is set.\n    event ZbyteValueInNativeEthGweiSet(uint256);\n    /// @notice event (0xd7a7cf8c): Zbyte burn factor is set.\n    event ZbyteBurnFactorSet(uint256);\n    /// @notice event (0xe603ec36): Zbyte price feeder is set.\n    event ZbytePriceFeederSet(address);\n\n    /// @notice Sets the address of the ZbyteVToken.\n    /// @param zbyteVToken_ The address of the ZbyteVToken.\n    function setZbyteVToken(address zbyteVToken_) public onlyOwner {\n        LibDPlatBase.DiamondStorage storage _dsb = LibDPlatBase.diamondStorage();\n        _dsb.zbyteVToken = zbyteVToken_;\n        emit ZbyteVTokenAddressSet(zbyteVToken_);\n    }\n\n    /// @notice Sets the Zbyte Price Feeder address.\n    /// @param zbytePriceFeeder_ Zbyte Price Feeder address.\n    function setZbytePriceFeeder(address zbytePriceFeeder_) public onlyOwner {\n        LibDPlatBase.DiamondStorage storage _dsb = LibDPlatBase.diamondStorage();\n        _dsb.zbytePriceFeeder = zbytePriceFeeder_;\n        emit ZbytePriceFeederSet(zbytePriceFeeder_);\n    }\n\n    /// @notice Gets the address of the ZbyteVToken.\n    /// @return The address of the ZbyteVToken.\n    function getZbyteVToken() public view returns (address) {\n        return LibDPlatBase._getZbyteVToken();\n    }\n\n    function getZbytePriceFeeder() public view returns (address) {\n        return LibDPlatBase._getZbytePriceFeeder();\n    }\n}\n"
    },
    "contracts/dplat/ZbyteDPlatDiamond/ZbyteDPlatPaymentFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\nimport \"./LibDPlat.sol\";\nimport \"../../utils/ZbyteContextDiamond.sol\";\nimport \"../../interface/dplat/IEnterprisePaymentPolicy.sol\";\nimport \"../../interface/dplat/IZbytePriceFeeder.sol\";\nimport \"../ZbyteVToken.sol\";\n\n/// @title Zbyte DPlat Payment Facet\ncontract ZbyteDPlatPaymentFacet is ZbyteContextDiamond {\n\n    /// events\n    /// @notice Event(0x0f1db6a3) Address of the payer, enterprise hash, DPlat, Infra and Royalty Fee\n    event PreExecFees(address,bytes4,uint256,uint256,uint256);\n    /// @notice Event(0x5ccdbb95) Address of the payer, Pre Exec charge, Post Exec Charge, Refund if neccessary\n    event PostExecFees(address,uint256,uint256,uint256);\n\n    /// error\n    /// @notice Error(0x91acbad9) Error details for getRoyaltyFee failure.\n    error GetRoyaltyFeeInZbyteFailed(bytes);\n\n    /// @notice Determines the payer for a transaction.\n    /// @notice In the absence of an enteprise policy, if a dapp or user is registered with ent,\n    /// ent will pay for the call, as long as it has balance\n    /// @param user_ The user's address.\n    /// @param dapp_ The Dapp's address.\n    /// @param functionSig_ The function signature (bytes4).\n    /// @param amount_ The transaction amount.\n    /// @return The payer's address.\n    function getPayer(address user_, address dapp_, bytes4 functionSig_, uint256 amount_) public view returns (bytes4, uint256, address) {\n        bytes4 _dappEnterprise = LibDPlatRegistration.isEnterpriseDappRegistered(dapp_);\n\n        if (_dappEnterprise != bytes4(0)) {\n            address _enterpriseProvider = LibDPlatRegistration.isEnterpriseRegistered(_dappEnterprise);\n            if (_enterpriseProvider != address(0) && LibDPlatRegistration.isProviderRegistered(_enterpriseProvider)) {\n                uint256 _enterpriseLimit = LibDPlatRegistration._getEnterpriseLimit(_dappEnterprise);\n                address _enterprisePolicy = LibDPlatRegistration._doesEnterpriseHavePolicy(_dappEnterprise);\n\n                if (_enterpriseLimit > amount_) {\n                    if (_enterprisePolicy != address(0)) {\n                        bool _willEnterprisePay = IEnterprisePaymentPolicy(_enterprisePolicy).isUserOrDappEligibleForPayment(user_, dapp_, functionSig_, amount_);\n                        if (_willEnterprisePay) {\n                            return (_dappEnterprise, _enterpriseLimit, _enterpriseProvider);\n                        }\n                    } else {\n                        //In absence of an ent policy, if a dapp is registered with ent\n                        //ent will pay for any call to that dapp, as long as it has balance\n                        return (_dappEnterprise, _enterpriseLimit, _enterpriseProvider);\n\n                    }\n                }\n            }\n        }\n\n        bytes4 _userEnterprise = LibDPlatRegistration.isEnterpriseUserRegistered(user_);\n        if (_userEnterprise != bytes4(0) && _userEnterprise != _dappEnterprise) {\n\n            address _enterpriseProvider = LibDPlatRegistration.isEnterpriseRegistered(_userEnterprise); \n            if (_enterpriseProvider != address(0) && LibDPlatRegistration.isProviderRegistered(_enterpriseProvider)) {\n\n                uint256 _enterpriseLimit = LibDPlatRegistration._getEnterpriseLimit(_userEnterprise);\n                address _enterprisePolicy = LibDPlatRegistration._doesEnterpriseHavePolicy(_userEnterprise);\n\n                if (_enterpriseLimit > amount_) {\n                    if (_enterprisePolicy != address(0)) {\n                        bool _willEnterprisePay = IEnterprisePaymentPolicy(_enterprisePolicy).isUserOrDappEligibleForPayment(user_, dapp_, functionSig_, amount_);\n                        if (_willEnterprisePay) {\n                            return (_userEnterprise, _enterpriseLimit, _enterpriseProvider);\n                        }\n                    } else {\n                        //In absence of an ent policy, if a user is registered with ent\n                        //ent will pay for any call from that user, as long as it has balance\n                        return (_userEnterprise, _enterpriseLimit, _enterpriseProvider);\n                    }\n                }\n            }\n        }\n        return (bytes4(0), uint256(0), user_);\n    }\n\n\n    function _chargeAndUpdate() internal {\n\n    }\n\n    /// @notice Pre Execution (Finds the payer and charges in ZbyteVToken)\n    /// @param dapp_ The Dapp's address.\n    /// @param user_ The user's address.\n    /// @param functionSig_ The function signature (bytes4).\n    /// @param ethChargeAmount_ The Ether amount to charge.\n    function preExecute(\n        address dapp_,\n        address user_,\n        bytes4 functionSig_,\n        uint256 ethChargeAmount_\n    ) public onlyForwarder returns(address) {\n        LibDPlatBase.DiamondStorage storage _dsb = LibDPlatBase.diamondStorage();\n        uint256 _dPlatFee = IZbytePriceFeeder(_dsb.zbytePriceFeeder).getDPlatFeeInZbyte();\n        uint256 _infraFee = IZbytePriceFeeder(_dsb.zbytePriceFeeder).convertEthToEquivalentZbyte(ethChargeAmount_);\n        uint256 _royaltyFee;\n        address _royaltyPayer;\n        address _royaltyReceiver;\n\n        bytes4  _feePayerEnterprise;\n        uint256 _currentEnterprisePayLimit;\n        address _feePayer;\n        (_feePayerEnterprise, _currentEnterprisePayLimit, _feePayer) = getPayer(user_, dapp_, functionSig_, _infraFee + _dPlatFee);\n\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        bytes4 functionSelector = bytes4(keccak256(\"getRoyaltFeeInZbyte(address,address,bytes4,address,uint256)\"));\n        LibDiamond.FacetAddressAndPosition memory _facetAddressAndPosition = ds.selectorToFacetAndPosition[functionSelector];\n        bytes memory getRoyaltFeeInZbyteCall = abi.encodeWithSelector(functionSelector, dapp_,user_,functionSig_,_feePayer,_infraFee + _dPlatFee);\n        (bool _success, bytes memory _result) = address(_facetAddressAndPosition.facetAddress).delegatecall(getRoyaltFeeInZbyteCall);\n\n        if(_success) {\n            (_royaltyFee, _royaltyReceiver, _royaltyPayer) = abi.decode(_result, (uint256,address,address));\n        } else {\n            revert GetRoyaltyFeeInZbyteFailed(_result);\n        }\n\n        uint256 _totalCharge = _infraFee + _dPlatFee;\n        if(_infraFee != 0 || _dPlatFee != 0 || _royaltyFee != 0) {\n            if(_feePayerEnterprise != bytes4(0)) {\n                if (_royaltyPayer == _feePayer) \n                    _totalCharge += _royaltyFee;\n\n                address _enterprisePolicy = LibDPlatRegistration._doesEnterpriseHavePolicy(_feePayerEnterprise);\n                if(_enterprisePolicy != address(0)) {\n                    IEnterprisePaymentPolicy(_enterprisePolicy).updateEnterpriseEligibility(user_, dapp_, functionSig_, _totalCharge);\n                }\n\n                LibDPlatRegistration._setEntepriseLimit(_feePayerEnterprise, _currentEnterprisePayLimit - (_totalCharge));\n            }\n            if(_infraFee != 0)\n                ZbyteVToken(payable(_dsb.zbyteVToken)).transferFrom(_feePayer, address(this), _infraFee);\n            if(_dPlatFee != 0)\n                ZbyteVToken(payable(_dsb.zbyteVToken)).burn(_feePayer, _dPlatFee);\n            if(_royaltyFee != 0) \n                ZbyteVToken(payable(_dsb.zbyteVToken)).transferFrom(_royaltyPayer, _royaltyReceiver, _royaltyFee);\n        }\n\n        LibDPlatBase._setPreExecStates(_feePayerEnterprise);\n        emit PreExecFees(_feePayer, _feePayerEnterprise, _infraFee, _dPlatFee, _royaltyFee);\n        return _feePayer;\n    }\n\n\n    /// @dev Executes a transaction and handles Zbyte-related operations.\n    /// @param payer_ The address of the payer initiating the execution.\n    /// @param executeResult_ A boolean indicating the success of the execution.\n    /// @param reqValue_ The amount of Ether sent with the execution request.\n    /// @param gasConsumedEth_ The amount of Ether consumed for gas during execution.\n    /// @param preChargeEth_ The amount of Ether charged before execution.\n    /// This function can only be called by the `onlyForwarder` modifier.\n    function postExecute(address payer_,\n                         bool executeResult_,\n                         uint256 reqValue_,\n                         uint256 gasConsumedEth_,\n                         uint256 preChargeEth_) public onlyForwarder {\n        LibDPlatBase.DiamondStorage storage _dsb = LibDPlatBase.diamondStorage();\n        LibDPlatBase.PreExecStates memory _preExecStates = LibDPlatBase._getPreExecStates();\n        uint256 _infraFee;\n\n        // Execute was successfull, also consider eth sent to execute request\n        if (executeResult_) {\n            gasConsumedEth_ += reqValue_;\n        }       \n        uint256 _chargeEth = gasConsumedEth_ >= preChargeEth_ ? gasConsumedEth_ - preChargeEth_ : 0;\n        uint256 _refundEth = gasConsumedEth_ > preChargeEth_ ? 0 : preChargeEth_ - gasConsumedEth_;\n\n        uint256 _infraFeePreCharge = IZbytePriceFeeder(_dsb.zbytePriceFeeder).convertEthToEquivalentZbyte(preChargeEth_);\n\n        if(_chargeEth != 0) {\n            uint256 _infraFeeCharge = IZbytePriceFeeder(_dsb.zbytePriceFeeder).convertEthToEquivalentZbyte(_chargeEth);\n            ZbyteVToken(payable(_dsb.zbyteVToken)).transfer(msg.sender, _infraFeePreCharge);\n            ZbyteVToken(payable(_dsb.zbyteVToken)).transferFrom(payer_, msg.sender, _infraFeeCharge);\n            if(_preExecStates.enterprise != bytes4(0)) {\n                uint256 _currentEnterpriseLimit = LibDPlatRegistration._getEnterpriseLimit(_preExecStates.enterprise);\n                LibDPlatRegistration._setEntepriseLimit(_preExecStates.enterprise, _currentEnterpriseLimit - (_infraFeeCharge));\n            }\n            _infraFee = _infraFeePreCharge + _infraFeeCharge;\n        }\n\n        if(_refundEth != 0) {\n            uint256 _infraFeePreChargeRefund = IZbytePriceFeeder(_dsb.zbytePriceFeeder).convertEthToEquivalentZbyte(_refundEth);\n            ZbyteVToken(payable(_dsb.zbyteVToken)).transfer(payer_, _infraFeePreChargeRefund);\n            ZbyteVToken(payable(_dsb.zbyteVToken)).transfer(msg.sender, _infraFeePreCharge - _infraFeePreChargeRefund);\n            if(_preExecStates.enterprise != bytes4(0)) {\n                uint256 _currentEnterpriseLimit = LibDPlatRegistration._getEnterpriseLimit(_preExecStates.enterprise);\n                LibDPlatRegistration._setEntepriseLimit(_preExecStates.enterprise, _currentEnterpriseLimit + (_infraFeePreChargeRefund));\n            }\n            _infraFee = _infraFeePreCharge - _infraFeePreChargeRefund;\n        }\n\n        emit PostExecFees(payer_, _infraFeePreCharge, _chargeEth, _refundEth);\n    }\n}\n"
    },
    "contracts/dplat/ZbyteDPlatDiamond/ZbyteDPlatRegistrationFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\nimport \"./LibDPlat.sol\";\nimport \"../../utils/LibCommonErrors.sol\";\nimport \"../../utils/ZbyteContextDiamond.sol\";\n\n/// @notice Zbyte DPlat Registration Facet\n/// @dev Zbyte DPlat Registration Facet\ncontract ZbyteDPlatRegistrationFacet is ZbyteContextDiamond {\n\n    /// events\n    /// @notice event (0x2a3043c9): Zbyte DPlat provider is registered.\n    event ZbyteDPlatProviderRegistred(address,bool);\n    /// @notice event (0xb0c62993): Zbyte DPlat provider agent is registered.\n    event ZbyteDPlatProviderAgentRegistered(address,address);\n    /// @notice event (0xa98ff618): Zbyte DPlat enterprise is registered.\n    event ZbyteDPlatEnterpriseRegistered(bytes4,address);\n    /// @notice event (0x83439d26): Zbyte DPlat enterprise user is registered.\n    event ZbyteDPlatEnterpriseUserRegistered(address,bytes4);\n    /// @notice event (0x822d049d): Zbyte DPlat dapp is registered.\n    event ZbyteDPlatDappRegistered(address,bytes4);\n    /// @notice event (0x75ee1f8e): Zbyte DPlat enterprise limit is set.\n    event ZbyteDPlatEnterpriseLimitSet(bytes4,uint256,uint256);\n\n    ///errors\n    /// @notice error (0x74f7822a): Provider already registered.\n    error ProviderAlreadyRegistered(address);\n    /// @notice error (0x232cb27a): Provider not registered.\n    error ProviderNotRegistered(address);\n    /// @notice error (0x128c088b): Invalid enterprise hash.\n    error InvalidEnterprise(bytes4);\n    /// @notice error (0xe751ad65): Provider Agent is already registered.\n    error ProviderAgentAlreadyRegistered(address);\n    /// @notice error (0xd0141a6a): Not a registered provider agent.\n    error ProviderAgentNotRegistered(address);\n    /// @notice error (0x96271599): Invalid provider.\n    error InvalidProvider(address);\n    /// @notice error (0x6d998cea): Enterprise is already registered.\n    error EnterpriseAlreadyRegistered(bytes4);\n    /// @notice error (0xbd825961): Enterprise is not registered.\n    error EnterpriseNotRegistered(bytes4);\n    /// @notice error (0xca61871b): Not a registered provider.\n    error NotARegisteredProvider(address);\n    /// @notice error (0x43469070): Enterprise user is already registered.\n    error EnterpriseUserAlreadyRegistered(address);\n    /// @notice error (0x1b7bfcf8): Enterprise user is not registered.\n    error EnterpriseUserNotRegistered(address);\n    /// @notice error (0xbcb8afa4): Enterprise dapp is already registered.\n    error EnterpriseDappAlreadyRegistered(address);\n    /// @notice error (0x31b254a2): Enterprise dapp is not registered.\n    error EnterpriseDappNotRegistered(address);\n\n    /// @notice Internal function to set the registration status of a provider.\n    /// @param provider_ The address of the provider whose registration status will be set.\n    /// @param set_ A boolean indicating whether to set the provider as registered or not.\n    /// @dev This function is used internally to manage the registration status of providers.\n    function _setRegisteredProvider(address provider_, bool set_) internal {\n        if (provider_ == address(0)) {\n            revert LibCommonErrors.ZeroAddress();\n        }\n        LibDPlatProvider.DiamondStorage storage _dsp = LibDPlatProvider.diamondStorage();\n        _dsp.registeredProviders[provider_] = set_;\n        emit ZbyteDPlatProviderRegistred(provider_, set_);\n    }\n\n    /// @notice Internal function to set the registration of a provider agent.\n    /// @param agent_ The address of the agent whose provider registration will be set.\n    /// @param provider_ The address of the provider associated with the agent.\n    /// @dev This function is used internally to manage the registration of provider agents.\n    function _setRegisteredProviderAgent(address agent_, address provider_) internal {\n        if (agent_ == address(0)) {\n            revert LibCommonErrors.ZeroAddress();\n        }\n        LibDPlatProvider.DiamondStorage storage _dsp = LibDPlatProvider.diamondStorage();\n        _dsp.registeredProviderAgent[agent_] = provider_;\n        emit ZbyteDPlatProviderAgentRegistered(agent_, provider_);\n    }\n\n    /// @notice Internal function to set the registration status of an enterprise.\n    /// @param enterprise_ The identifier of the enterprise whose registration status will be set.\n    /// @param provider_ The address of the provider associated with the enterprise.\n    /// @dev This function is used internally to manage the registration status of enterprises.\n    function _setRegisteredEnterprise(bytes4 enterprise_, address provider_) internal {\n        if (enterprise_ == bytes4(0)) {\n            revert InvalidEnterprise(enterprise_);\n        }\n        LibDPlatRegistration.DiamondStorage storage _dsr = LibDPlatRegistration.diamondStorage();\n        _dsr.registeredEnterprises[enterprise_] = provider_;\n        emit ZbyteDPlatEnterpriseRegistered(enterprise_, provider_);\n    }\n\n    /// @notice Internal function to set the registration status of an enterprise user.\n    /// @param user_ The address of the user whose enterprise registration will be set.\n    /// @param enterprise_ The identifier of the enterprise associated with the user.\n    /// @dev This function is used internally to manage the registration status of enterprise users.\n    function _setRegisteredEnterpriseUser(address user_, bytes4 enterprise_) internal {\n        if (user_ == address(0)) {\n            revert LibCommonErrors.ZeroAddress();\n        }\n        LibDPlatRegistration.DiamondStorage storage _dsr = LibDPlatRegistration.diamondStorage();\n        _dsr.registeredEnterpriseUsers[user_] = enterprise_;\n        emit ZbyteDPlatEnterpriseUserRegistered(user_,enterprise_);\n    }\n\n    /// @notice Internal function to set the registration status of an enterprise Dapp.\n    /// @param dapp_ The address of the Dapp whose enterprise registration will be set.\n    /// @param enterprise_ The identifier of the enterprise associated with the Dapp.\n    /// @dev This function is used internally to manage the registration status of enterprise Dapps.\n    function _setRegisteredEnterpriseDapp(address dapp_, bytes4 enterprise_) internal {\n        if (dapp_ == address(0)) {\n            revert LibCommonErrors.ZeroAddress();\n        }\n        LibDPlatRegistration.DiamondStorage storage _dsr = LibDPlatRegistration.diamondStorage();\n        _dsr.registeredDapps[dapp_] = enterprise_;\n        emit ZbyteDPlatDappRegistered(dapp_, enterprise_);\n    }\n\n    /// @notice Checks if a provider is registered.\n    /// @param provider_ The address of the provider to check.\n    /// @return A boolean indicating whether the provider is registered.\n    function isProviderRegistered(address provider_) public view returns (bool) {\n        return LibDPlatRegistration.isProviderRegistered(provider_);\n    }\n\n    /// @notice Checks if a provider agent is registered and returns the associated provider's address.\n    /// @param agent_ The address of the provider agent to check.\n    /// @return The address of the associated registered provider.\n    function isProviderAgentRegistered(address agent_) public view returns (address) {\n        return LibDPlatRegistration.isProviderAgentRegistered(agent_);\n    }\n\n    /// @notice Checks if an enterprise is registered and returns the associated provider's address.\n    /// @param enterprise_ The identifier of the enterprise to check.\n    /// @return The address of the associated registered provider.\n    function isEnterpriseRegistered(bytes4 enterprise_) public view returns (address) {\n        return LibDPlatRegistration.isEnterpriseRegistered(enterprise_);\n    }\n\n    /// @notice Checks if an enterprise user is registered and returns the associated enterprise identifier.\n    /// @param user_ The address of the user to check.\n    /// @return The identifier of the associated registered enterprise.\n    function isEnterpriseUserRegistered(address user_) public view returns (bytes4) {\n        return LibDPlatRegistration.isEnterpriseUserRegistered(user_);\n    }\n\n    /// @notice Checks if an enterprise Dapp is registered and returns the associated enterprise identifier.\n    /// @param dapp_ The address of the Dapp to check.\n    /// @return The identifier of the associated registered enterprise.\n    function isEnterpriseDappRegistered(address dapp_) public view returns (bytes4) {\n        return LibDPlatRegistration.isEnterpriseDappRegistered(dapp_);\n    }\n\n    /// @notice Registers a provider.\n    /// @dev Relation between provider, agent, enterprise, users and dapps is as follows:\n    ///\n    /// zbyte\\\n    ///____(1) <--------> (n) provider\\\n    ///____________________________(1) <--------> (n) agent\\\n    ///____________________________(1) <--------> (n) enterprise\\\n    ///________________________________________________________(1) <--------> (n) user\\\n    ///________________________________________________________(1) <--------> (n) dapp\n    ///\n    ///   For an enterprise usecase, an enterprise can allow users to invoke registered dapps.\\\n    ///   Users can invoke the contract functions without any need to hold crypto assets.\\\n    ///   L1 needed for the call is given by the authorized workers and providers compensate them in vERC20.\\\n    ///\\\n    ///   For opensource usecase,\\\n    ///   Users can invoke the contract functions without any need to hold L1 assets.\\\n    ///   L1 needed for the call is given by the authorized workers and the users compensate them in vERC20\\\n    ///\\\n    ///   NOTE: When one of the components (provider, enterprise, agent, user or dapp) is deregistered,\\\n    ///    all the other components registered under it remain registered.\\\n    ///    So, if the component is registered again, the entire subtree becomes active again\n    function registerProvider() public {\n        if (isProviderRegistered(_msgSender())) revert ProviderAlreadyRegistered(_msgSender());\n        _setRegisteredProvider(_msgSender(), true);\n        _setRegisteredProviderAgent(_msgSender(), _msgSender());\n    }\n\n    /// @notice Deregisters a provider.\n    function deregisterProvider() public {\n        if (!isProviderRegistered(_msgSender())) revert ProviderNotRegistered(_msgSender());\n        _setRegisteredProvider(_msgSender(), false);\n        _setRegisteredProviderAgent(_msgSender(), address(0));\n    }\n\n    /// @notice Registers a provider agent.\n    /// @param agent_ The address of the provider agent to register.\n    function registerProviderAgent(address agent_) public {\n        if (!isProviderRegistered(_msgSender())) revert ProviderNotRegistered(_msgSender());\n        if (isProviderAgentRegistered(agent_) != address(0)) revert ProviderAgentAlreadyRegistered(agent_);\n        _setRegisteredProviderAgent(agent_, _msgSender());\n    }\n\n    /// @notice Deregisters a provider agent.\n    /// @param agent_ The address of the provider agent to deregister.\n    function deRegisterProviderAgent(address agent_) public {\n        address _provider = isProviderAgentRegistered(agent_);\n        if (_provider == address(0))  revert ProviderAgentNotRegistered(agent_);\n        if (_provider != _msgSender())  revert InvalidProvider(_msgSender());\n        if (!isProviderRegistered(_msgSender())) revert ProviderNotRegistered(_msgSender());\n\n        _setRegisteredProviderAgent(agent_, address(0));\n    }\n\n    /// @notice Registers an enterprise.\n    /// @param enterprise_ The bytes4 identifier of the enterprise to register.\n    function registerEnterprise(bytes4 enterprise_) public {\n        address _agentProvider = isProviderAgentRegistered(_msgSender());\n        address _enterpriseProvider = isEnterpriseRegistered(enterprise_);\n        if (_agentProvider == address(0)) revert ProviderAgentNotRegistered(_msgSender());\n        if (!isProviderRegistered(_agentProvider)) revert NotARegisteredProvider(_agentProvider);\n        if (_enterpriseProvider != address(0)) revert EnterpriseAlreadyRegistered(enterprise_);\n\n        _setRegisteredEnterprise(enterprise_, _agentProvider);\n    }\n\n    /// @notice Deregisters an enterprise.\n    /// @param enterprise_ The bytes4 identifier of the enterprise to deregister.\n    function deregisterEnterprise(bytes4 enterprise_) public {\n        address _agentProvider = isProviderAgentRegistered(_msgSender());\n        address _enterpriseProvider = isEnterpriseRegistered(enterprise_);\n        if (_agentProvider == address(0)) revert ProviderAgentNotRegistered(_msgSender());\n        if (!isProviderRegistered(_agentProvider)) revert NotARegisteredProvider(_agentProvider);\n        if (_enterpriseProvider != _agentProvider) revert InvalidProvider(_agentProvider);\n        if (_enterpriseProvider == address(0)) revert EnterpriseNotRegistered(enterprise_);\n\n        _setRegisteredEnterprise(enterprise_, address(0));\n    }\n\n    /// @notice Registers an enterprise user.\n    /// @param user_ The address of the user to register.\n    /// @param enterprise_ The bytes4 identifier of the enterprise.\n    function registerEnterpriseUser(address user_, bytes4 enterprise_) public {\n        if (enterprise_ == bytes4(0)) revert InvalidEnterprise(enterprise_);\n        address _agentProvider = isProviderAgentRegistered(_msgSender());\n        if (_agentProvider == address(0)) revert ProviderAgentNotRegistered(_msgSender());\n        if (!isProviderRegistered(_agentProvider)) revert NotARegisteredProvider(_agentProvider);\n        if (isEnterpriseRegistered(enterprise_) == address(0)) revert EnterpriseNotRegistered(enterprise_);\n        if (isEnterpriseRegistered(enterprise_) != _agentProvider) revert InvalidProvider(_agentProvider);\n        if (isEnterpriseUserRegistered(user_) != bytes4(0)) revert EnterpriseUserAlreadyRegistered(user_);\n\n        _setRegisteredEnterpriseUser(user_, enterprise_);\n    }\n\n    /// @notice Deregisters an enterprise user.\n    /// @param user_ The address of the user to deregister.\n    function deregisterEnterpriseUser(address user_) public {\n        bytes4  _userEnterprise = isEnterpriseUserRegistered(user_);\n        address _agentProvider = isProviderAgentRegistered(_msgSender());\n        if (_userEnterprise == bytes4(0)) revert EnterpriseUserNotRegistered(user_);\n        if (isEnterpriseRegistered(_userEnterprise) == address(0)) revert EnterpriseNotRegistered(_userEnterprise);\n        if (_agentProvider == address(0)) revert ProviderAgentNotRegistered(_msgSender());\n        if (!isProviderRegistered(_agentProvider)) revert NotARegisteredProvider(_agentProvider);\n        if (isEnterpriseRegistered(_userEnterprise) != _agentProvider) revert InvalidProvider(_agentProvider);\n\n        _setRegisteredEnterpriseUser(user_, bytes4(0));\n    }\n\n    /// @notice Registers a Dapp for an enterprise.\n    /// @param dapp_ The address of the Dapp to register.\n    /// @param enterprise_ The bytes4 identifier of the enterprise.\n    function registerDapp(address dapp_, bytes4 enterprise_) public {\n        if (enterprise_ == bytes4(0)) revert InvalidEnterprise(enterprise_);\n        address _agentProvider = isProviderAgentRegistered(_msgSender());\n        if (_agentProvider == address(0)) revert ProviderAgentNotRegistered(_msgSender());\n        if (!isProviderRegistered(_agentProvider)) revert NotARegisteredProvider(_agentProvider);\n        if (isEnterpriseRegistered(enterprise_) == address(0)) revert EnterpriseNotRegistered(enterprise_);\n        if (isEnterpriseRegistered(enterprise_) != _agentProvider) revert InvalidProvider(_agentProvider);\n        if (isEnterpriseDappRegistered(dapp_) != bytes4(0)) revert EnterpriseDappAlreadyRegistered(dapp_);\n\n        _setRegisteredEnterpriseDapp(dapp_, enterprise_);\n    }\n\n    /// @notice Deregisters a Dapp for an enterprise.\n    /// @param dapp_ The address of the Dapp to deregister.\n    function deregisterDapp(address dapp_) public {\n        bytes4  _dappEnterprise = isEnterpriseDappRegistered(dapp_);\n        address _agentProvider = isProviderAgentRegistered(_msgSender());\n        if (_dappEnterprise == bytes4(0)) revert EnterpriseDappNotRegistered(dapp_);\n        if (isEnterpriseRegistered(_dappEnterprise) == address(0)) revert EnterpriseNotRegistered(_dappEnterprise);\n        if (_agentProvider == address(0)) revert ProviderAgentNotRegistered(_msgSender());\n        if (!isProviderRegistered(_agentProvider)) revert NotARegisteredProvider(_agentProvider);\n        if (isEnterpriseRegistered(_dappEnterprise) != _agentProvider) revert InvalidProvider(_agentProvider);\n\n        _setRegisteredEnterpriseDapp(dapp_, bytes4(0));\n    }\n\n    /// @notice Sets the enterprise limit for a specific enterprise.\n    /// @param enterprise_ The bytes4 identifier of the enterprise.\n    /// @param amount_ The new limit amount.\n    function setEnterpriseLimit(bytes4 enterprise_, uint256 amount_) public {\n        address _agentProvider = isProviderAgentRegistered(_msgSender());\n        address _enterpriseProvider = isEnterpriseRegistered(enterprise_);\n        if (_agentProvider == address(0)) revert ProviderAgentNotRegistered(_msgSender());\n        if (!isProviderRegistered(_agentProvider)) revert NotARegisteredProvider(_agentProvider);\n        if (_enterpriseProvider != _agentProvider) revert InvalidProvider(_agentProvider);\n        if (_enterpriseProvider == address(0)) revert EnterpriseNotRegistered(enterprise_);\n\n        LibDPlatRegistration._setEntepriseLimit(enterprise_, amount_);\n    }\n\n    function getEnterpriseLimit(bytes4 enterprise_) public view returns(uint256) {\n        return LibDPlatRegistration._getEnterpriseLimit(enterprise_);\n    }\n}\n"
    },
    "contracts/dplat/ZbyteDPlatDiamond/ZbyteDPlatRoyaltyFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\nimport \"../../utils/ZbyteContextDiamond.sol\";\n\nlibrary LibDPlatRoyalty {\n    /// @notice Diamond storage for DPlat Base struct\n    struct DiamondStorage {\n        mapping (address => uint256) royaltyDapp;\n    }\n\n    /// @notice Retrieves the DiamondStorage struct for the library.\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 storagePosition = keccak256(\"diamond.storage.LibDPlatRoyalty.v1\");\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n}\n\n/**\n * @title ZbyteDPlatRoyaltyFacet\n * @dev This contract extends ZbyteContextDiamond and provides functionality related to royalty fees in Zbyte.\n */\ncontract ZbyteDPlatRoyaltyFacet is ZbyteContextDiamond {\n\n    /**\n     * @dev Retrieves the royalty fee in Zbyte for a specific DApp function.\n     * @param dapp_ The address of the DApp.\n     * @param user_ The address of the user involved in the DApp function.\n     * @param functionSig_ The function signature of the DApp function.\n     * @param payer_ The address of the entity paying the royalty fee.\n     * @param zbyteCharge_ The Zbyte charge associated with the DApp function.\n     * @return uint256 The royalty fee in Zbyte.\n     * @return address The address of the payer.\n     */\n    function getRoyaltFeeInZbyte(\n        address dapp_,\n        address user_,\n        bytes4 functionSig_,\n        address payer_,\n        uint256 zbyteCharge_\n    ) external view returns(uint256, address, address) {\n        (user_, functionSig_, zbyteCharge_);\n\n        LibDPlatRoyalty.DiamondStorage storage _dsr = LibDPlatRoyalty.diamondStorage();\n        /// royalty amount, receiver address, payer address \n        return (_dsr.royaltyDapp[dapp_], dapp_,payer_);\n    }\n}\n"
    },
    "contracts/dplat/ZbyteForwarderDplat.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/metatx/MinimalForwarder.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interface/dplat/IZbyteDPlat.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title The ZBYT Dplat forwarder contract\n/// Todo: Integrate chargeAndBurnZbyteVToken and refundZbyteVToken with ZbyteDPlat\ncontract ZbyteForwarderDPlat is Ownable, MinimalForwarder, ReentrancyGuard {\n    /// events\n    /// @notice event (0xeae099e1): Forwarder address is set.\n    event ForwarderDplatSet(address);\n    /// @notice event (0x6342abcf): Forwarder minimum processing gas is set.\n    event ForwarderDplatMinimumProcessingGasSet(uint256);\n    /// @notice event (0xe1554bda): Forwarder worker is registered.\n    event ForwarderDplatWorkerRegistered(address,bool);\n    /// @notice event (0xe5cac075): Refund Eth to payer.\n    event RefundEth(address,uint256);\n    /// @notice event (0x5c3206c6): Execute result and return data\n    event ZbyteForwarderDPlatExecute(bool,bytes);\n    /// @notice event (0x1f32728a): Forwarder post exec gas is set.\n    event ForwarderDplatPostExecGasSet(uint256);\n\n    /// errors\n    /// @notice error (0xd92e233d): Address is zero. \n    error ZeroAddress();\n    /// @notice error (0xfb3dd446): Array sizes don't match.\n    error ArraySizeMismatch(uint256, uint256);\n    /// @notice error (0xf9309a09): Not enough ether sent the function.\n    error NotEnoughEtherSent(uint256, uint256);\n    /// @notice error (0xb7da4a55): Failed to send ether.\n    error FailedToSendEther(address,uint256,bytes);\n    /// @notice error (0x9059e055): Not a worker.\n    error NotAWorker(address);\n\n    // Minimum processing gas\n    /// @notice Minimum amount of gas needed for a call via the forwarder\n    uint256 public minProcessingGas;\n    /// @notice Address of the Zbyte DPlat contract\n    address public zbyteDPlat;\n    /// @notice Amount of gas needed for a post execute to the DPlat\n    uint256 public postExecGas;\n    /// @notice Mapping of registered workers\n    mapping (address => bool) public registeredWorkers;\n\n    /// @notice Modifier to restrict a function to only be callable by registered workers.\n    /// @dev The function using this modifier will only execute if the sender's address is a registered worker\\\n    ///  It will revert with a 'NotAWorker' error if the sender is not a registered worker.\n    modifier onlyWorker() {\n        if(!registeredWorkers[msg.sender]) revert NotAWorker(msg.sender);\n        _;\n    }\n\n    /// @notice Sets the post execute processing gas\n    /// @param postExecGas_ The new minimum processing gas value\n    function setPostExecGas(uint256 postExecGas_) public onlyOwner {\n        postExecGas = postExecGas_;\n        emit ForwarderDplatPostExecGasSet(postExecGas_);\n    }\n\n    /// @notice Sets the minimum processing gas\n    /// @param minProcessingGas_ The new minimum processing gas value\n    function setMinProcessingGas(uint256 minProcessingGas_) public onlyOwner {\n        minProcessingGas = minProcessingGas_;\n        emit ForwarderDplatMinimumProcessingGasSet(minProcessingGas_);\n    }\n\n    /// @notice Sets the address of the Zbyte DPlat contract\n    /// @param zbyteDPlat_ The address of the Zbyte DPlat contract\n    function setZbyteDPlat(address zbyteDPlat_) public onlyOwner {\n        if(zbyteDPlat_ == address(0)) revert ZeroAddress();\n        zbyteDPlat = zbyteDPlat_;\n        emit ForwarderDplatSet(zbyteDPlat_);\n    }\n\n    /// @notice Registers workers with the contract\n    /// @param workers_ An array of worker addresses\n    /// @param register_ An array of boolean values indicating registration status\n    function registerWorkers(address[] calldata workers_,\n                             bool[] calldata register_)\n                             public onlyOwner {\n        if(workers_.length != register_.length) revert ArraySizeMismatch(workers_.length, register_.length);\n\n        for(uint256 i = 0; i < workers_.length; i++) {\n            if(workers_[i] == address(0)) revert ZeroAddress();\n            registeredWorkers[workers_[i]] = register_[i];\n            emit ForwarderDplatWorkerRegistered(workers_[i], register_[i]);\n        }\n    }\n\n    /// @notice Executes a forward request, ensuring that it is called by a registered worker and handling gas fees.\n    /// @param req_ The forward request data containing the recipient, value, data, and other information.\n    /// @param signature_ The signature for the forward request (if required).\n    /// @return success A boolean indicating whether the execution was successful.\n    /// @return returndata The return data from the executed contract.\n    /// @dev This function facilitates call to a target contract while allowing the user to pay in DPLAT tokens\\\n    ///  The user would have received vERC20 necessary for the call execution.  An equivalent amount is charged in vERC20 from the user\\\n    ///  If the target contract accepts msg.value, equivalent of that is charged from the user during preExecute\\\n    ///  If preExecute collects more vERC20 than that is needed for the call, an event is emitted with the refund amount\\\n    ///  If the target contract sends any refund to the _msgSender(), the caller receives the refund directly\n    ///  If the target contract call reverts, msg.value is not sent to the target and an event is emitted with the refund amount\n    function zbyteExecute(ForwardRequest calldata req_,\n                          bytes calldata signature_)\n                          public\n                          payable\n                          onlyWorker\n                          nonReentrant\n                          returns(bool, bytes memory) {\n        uint256 _startGas = gasleft();\n        if(req_.value != msg.value) revert NotEnoughEtherSent(req_.value, msg.value);\n        uint256 _preChargeEth = minProcessingGas * tx.gasprice + req_.value;\n\n        address _payer = IZbyteDPlat(zbyteDPlat).preExecute(req_.to, req_.from, bytes4(req_.data[:4]), _preChargeEth);\n        (bool _success, bytes memory _returndata) = MinimalForwarder.execute(req_, signature_);\n\n\n        uint256 _gasConsumedEth = (postExecGas + _startGas - gasleft()) * tx.gasprice;\n        IZbyteDPlat(zbyteDPlat).postExecute(_payer, _success, req_.value, _gasConsumedEth, _preChargeEth);\n        emit ZbyteForwarderDPlatExecute(_success, _returndata);\n        return(_success, _returndata);\n    }\n\n    /// @notice Allows the owner of the contract to withdraw the contract's Ether balance.\n    /// @param receiver_ The address to which the Ether balance will be sent.\n    function withdrawEth(address receiver_) public onlyOwner {\n        (bool _sent, bytes memory _data) = receiver_.call{value: address(this).balance}(\"\");\n        (_data);\n        if(!_sent) revert FailedToSendEther(receiver_, address(this).balance, _data);\n    }\n}"
    },
    "contracts/dplat/ZbytePriceFeeder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\nimport \"../interface/dplat/IZbytePriceFeeder.sol\";\nimport \"../utils/ZbyteContext.sol\";\n\n\n/// @title ZbytePriceFeeder\n/// @notice Implements the IZbytePriceFeeder interface and provides functionality to manage gas costs and price conversions.\ncontract ZbytePriceFeeder is IZbytePriceFeeder, ZbyteContext {\n    /// @notice error (0xb3922495): Unauthorized caller.\n    error UnAuthorized(address);\n\n    /// @notice event (0x2ddb4d51): Worker is registered(true/false)\n    event WorkerRegistered(address,bool);\n\n    // Conversion factors\n    uint256 public nativeEthEquivalentZbyteInGwei;\n    uint256 public zbytePriceEquivalentInGwei;\n    uint256 public burnRateInMill;\n    /// @notice Authorized workers\n    mapping(address => bool) public authorizedWorkers;\n\n    constructor(address forwarder_) {\n        _setTrustedForwarder(forwarder_);\n    }\n\n    /**\n    * @dev Modifier to ensure that the sender is an authorized worker.\n    * @notice Reverts the transaction with an `UnAuthorized` error if the sender is not authorized.\n    */\n    modifier onlyAuthorized() {\n        if (!authorizedWorkers[_msgSender()]) {\n            revert UnAuthorized(_msgSender());\n        }\n        _;\n    }\n\n    /// @notice Registers or unregisters a worker, allowing or denying access to specific functionality.\n    /// @param worker_ The address of the worker to be registered or unregistered.\n    /// @param register_ A boolean indicating whether to register (true) or unregister (false) the worker.\n    function registerWorker(address worker_, bool register_) public onlyOwner {\n        authorizedWorkers[worker_] = register_;\n        emit WorkerRegistered(worker_, register_);\n    }\n\n    /// @notice Sets the equivalent Zbyte price in Gwei for native ETH.\n    /// @dev Example:\\\n    /// Say, Native Eth Price = 1$\\\n    /// Zbyte Price = 2\\\n    /// Ratio(Native Eth Price / Zbyte Price) = 100 / 2\\\n    /// nativeEthEquivalentZbyteInGwei = Ratio * 10 ^ decimals() / Gwei\\\n    ///                                = 50 * 10 ^ 18 / 10 ^ 9 = 50,000,000,000\\\n    /// @param nativeEthEquivalentZbyteInGwei_ The equivalent Zbyte price in Gwei for native ETH.\n    function setNativeEthEquivalentZbyteInGwei(uint256 nativeEthEquivalentZbyteInGwei_) public onlyAuthorized {\n        nativeEthEquivalentZbyteInGwei = nativeEthEquivalentZbyteInGwei_;\n        emit NativeEthEquivalentZbyteSet(nativeEthEquivalentZbyteInGwei_);\n    }\n\n    /// @notice Sets the Zbyte price in Gwei.\n    /// @dev Example:\\\n    /// Say, Unit Price = 1$\\\n    /// Zbyte Price = 2\\\n    /// Ratio(Unit Price / Zbyte Price) = 100 / 2\\\n    /// zbytePriceInGwei_ = Ratio * 10 ^ decimals() / Gwei\\\n    ///                                = 50 * 10 ^ 18 / 10 ^ 9 = 50,000,000,000\\\n    /// @param zbytePriceInGwei_ The Zbyte price in Gwei.\n    function setZbytePriceInGwei(uint256 zbytePriceInGwei_) public onlyAuthorized {\n        zbytePriceEquivalentInGwei = zbytePriceInGwei_;\n        emit ZbytePriceInGweiSet(zbytePriceInGwei_);\n    }\n\n    /// @notice Converts eth to equivalent Zbyte amount.\n    /// @dev Example:\\\n    /// Say, Native Eth Price = 1$\\\n    /// Zbyte Price = 2\\\n    /// nativeEthEquivalentZbyteInGwei = 50,000,000,000 Gwei (i.e. 1 Native Eth = 50 Zbyte)\\\n    /// ethAmount_  = 1,000,000,000,000,000,000 Wei (1 Native Eth)\\\n    /// zbyteAmount = (1,000,000,000,000,000,000 * 50,000,000,000) / 1,000,000,000\\\n    ///             = 50,000,000,000,000,000,000 Wei (50 ZBYT)\\\n    /// @param ethAmount_ Amount of eth.\n    /// @return Equivalent Amount of zbyte.\n    function convertEthToEquivalentZbyte(uint256 ethAmount_) public view returns (uint256) {\n        uint256 _zbyteAmount = (ethAmount_ * nativeEthEquivalentZbyteInGwei) / 10**9;\n        return _zbyteAmount;\n    }\n\n    /// @notice Converts price in millionths to Zbyte amount.\n    /// @dev Example:\\\n    /// Say, Unit Price = 1$\\\n    /// Zbyte Price = 2\\\n    /// So, zbytePriceEquivalentInGwei = 50,000,000,000 Gwei (i.e. 1 Unit = 50 Zbyte)\\\n    /// priceInMill_ = 20 Mill (i.e. (2 / 1000) Unit)\\\n    /// zbyteAmount = (20 * 50,000,000,000 * 1,000,000,000) / 1000\\\n    ///             = 1,000,000,000,000,000,000 Wei (1 ZBYT)\\\n    /// @param priceInMill_ Price in millionths.\n    /// @return Equivalent Zbyte amount.\n    function convertMillToZbyte(uint256 priceInMill_) public view returns (uint256) {\n        return (priceInMill_ * zbytePriceEquivalentInGwei * 10**9) / 1000;\n    }\n\n    /// @notice DPlat fee in terms of Zbyte\n    /// 1 Unit = 1000 Mill\n    /// @return DPlat fee\n    function getDPlatFeeInZbyte() public view returns(uint256) {\n        return convertMillToZbyte(burnRateInMill);\n    }\n\n    function setPrices(uint256 nativeEthEquivalentZbyteInGwei_, uint256 zbytePriceInGwei_) external onlyAuthorized {\n        setNativeEthEquivalentZbyteInGwei(nativeEthEquivalentZbyteInGwei_);\n        setZbytePriceInGwei(zbytePriceInGwei_);\n    }\n\n    /// @notice Sets burn rate for invoke calls in mill\n    /// 1 Unit = 1000 Mill\n    /// @param burnRate_ burn rate in mill\n    function setBurnRateInMill(uint256 burnRate_) public onlyOwner {\n        burnRateInMill = burnRate_;\n        emit BurnRateInMillSet(burnRate_);\n    } \n}"
    },
    "contracts/dplat/ZbyteVToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"../interface/dplat/IvERC20.sol\";\nimport \"../utils/Auth.sol\";\n\n/// @title The ZBYT vERC20 contract\n/// @dev The ZBYT vERC20 contract\ncontract ZbyteVToken is Ownable, Pausable, ERC20, AuthSimple, IvERC20 {\n    // errors\n    /// @notice error (0xd92e233d): Address is address(0)\n    error ZeroAddress();\n    /// @notice error (0xbf064619): Contract cannot receive ether\n    error CannotSendEther();\n    /// @notice error (b034fa06): The address sent for destroy is not valid\n    error InvalidDestroyAddress(address,address,address);\n\n    // events\n    /// @notice event (0xa16990bf) Paymaster address is set\n    event PaymasterAddressSet(address);\n    /// @notice event (0xcdb1d336) ZbyteDPlat address is set\n    event ZbyteDPlatAddressSet(address);\n\n    // Address to transfer 'burnt' tokens\n    address private burner;\n    // Address of the paymaster (forwarder) address\n    address private paymaster;\n    // Address of the DPlat contract\n    address private dplat;\n\n    /// @notice ZBYT ERC20 constructor\n    /// @param burner_ Burn account address (Tokens are locked here, not destroyed)\n    constructor(address burner_) ERC20(\"vZbyte\", \"vZBYT\") {\n        burner = burner_;\n    }\n\n    /// @notice Pauses the contract (mint, transfer and burn operations are paused)\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /// @notice Unpauses the paused contract\n    function unpause() external onlyOwner whenPaused {\n        _unpause();\n    }\n\n    /// @notice Set the paymaster (forwarder) address\n    /// @param paymaster_ Paymaster contract address\n    function setPaymasterAddress(address paymaster_) public onlyOwner {\n        if(paymaster_ == address(0)) {\n            revert ZeroAddress();\n        }\n        paymaster = paymaster_;\n\n        emit PaymasterAddressSet(paymaster_);\n    }\n\n    /// @notice Set the DPlat address\n    /// @param dplat_ DPlat contract address\n    function setZbyteDPlatAddress(address dplat_) public onlyOwner {\n        if(dplat_ == address(0)) {\n            revert ZeroAddress();\n        }\n        dplat = dplat_;\n\n        emit ZbyteDPlatAddressSet(dplat_);\n    }\n\n    /// @notice Transfer vERC20 from caller's account to receiver's account\n    /// @param to_ Receiver account address\n    /// @param value_ Amount of tokens to be transferred\n    /// @dev requiresAuth ensures that this call can be complely disabled, or only specific accounts can call\n    function transfer(address to_, uint256 value_)\n        public override(IERC20, ERC20)\n        requiresAuth whenNotPaused\n        returns (bool) {\n        ERC20.transfer(to_, value_);\n        return true;\n    }\n\n    /// @notice Transfers tokens from a specified address to another address.\n    /// @param from_ The address to transfer tokens from\n    /// @param to_ The address to transfer tokens to\n    /// @param value_ The amount of tokens to transfer\n    /// @dev requiresAuth ensures that this call can be complely disabled, or only specific accounts can call\n    ///  Allowing only specific accounts to perform transferFrom allows controlled transfer of vERC20 in future\n    function transferFrom(address from_, address to_, uint256 value_)\n        public override(IERC20, ERC20)\n        requiresAuth whenNotPaused\n        returns (bool) {\n        ERC20.transferFrom(from_, to_, value_);\n        return true;\n    }\n\n    /// @notice mint vZBYT ERC20\n    /// @param to_ Receiver address\n    /// @param amount_ Amount to mint to the address(to_) and approve to dplat\n    /// @dev The forwarder charges user in this ERC20 token for the contract call.  Approve the tokens to dplat at mint itself.\n    function mint(address to_, uint256 amount_)\n        external\n        requiresAuth whenNotPaused\n        returns(uint256) {\n        if(dplat == address(0)) {\n            revert ZeroAddress();\n        }\n        ERC20._mint(to_, amount_);\n        uint256 _allowance = ERC20.allowance(to_, dplat);\n        ERC20._approve(to_, dplat, _allowance + amount_);\n        return amount_;\n    }\n\n    /// @notice Transfer vERC20 to 'burner' address\n    /// @param from_ Sender address to burn tokens from\n    /// @param amount_ Amount to burn\n    /// @dev requiresAuth ensures that this call can be complely disabled, or only specific accounts can call\n    function burn(address from_, uint256 amount_) external\n        requiresAuth whenNotPaused\n        returns(uint256) {\n        _transfer(from_, burner, amount_);\n        return amount_;\n    }\n\n    /// @notice Destroy vERC20\n    /// @param from_ Paymaster/burner address from which tokens are destroyed\n    /// @dev This is called during withdraw / reconciliation only.  Withdraw is allowed only from the paymaster or burner address\n    function destroy(address from_)\n        external\n        requiresAuth whenNotPaused\n        returns(uint256) {\n        if(!((from_ == paymaster) || (from_ == burner))) {\n            revert InvalidDestroyAddress(from_,paymaster,burner);\n        }\n        uint256 _amount = this.balanceOf(from_);\n        _burn(from_, _amount);\n        return _amount;\n    }\n\n    /// @notice receive function (reverts)\n    receive() external payable {\n       revert CannotSendEther();\n    }\n}\n"
    },
    "contracts/interface/core/IEscrowERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\n/// @title The ZBYT ERC20 Escrow contract\ninterface IEscrowERC20 {\n    // errors\n    /// @notice Caller is not a valid relay\n    error InvalidRelay(address);\n    /// @notice error (0xd6facdff): The callback received was invalid\n    error InvalidCallbackMessage(uint256,uint256,uint256,uint256);\n    /// @notice error (0xcd9d7bb0): The ack in callback received was not found\n    error InvalidCallbackAck(uint256,bytes32,bool,uint256);\n    /// @notice error (0xed3fc6b3): Insufficient ERC20 for Deposit operation.\n    error InsufficientERC20ForDepositGas(uint256,uint256);\n    /// @notice error (0xb3922495): Unauthorized caller.\n    error UnAuthorized(address);\n\n    // events\n    /// @notice event (0x1a40ce6d): vERC20 contract address is set\n    event vERC20AddressSet(address,uint256);\n    /// @notice event (0x95290bcc): Core relay wrapper contract address is set\n    event RelayWrapperAddressSet(address);\n    /// @notice event (0xcae09af7): ERC20 tokens deposited\n    event ERC20Deposited(address,address,uint256,uint256,bytes32);\n    /// @notice event (0xf64578a8): ERC20 tokens deposit confirmed\n    event ERC20DepositConfirmed(bytes32,bool,uint256);\n    /// @notice event (0x8b923c21): ERC20 tokens withdrawn\n    event ERC20Withdrawn(address,address,address,uint256,bytes32);\n    /// @notice event (0x9c33bbca): ERC20 tokens withdraw failed\n    event ERC20WithdrawFailed(bytes32,bool,uint256);\n    /// @notice event (0xf5a60bd1): ERC20 tokens withdraw confirmed\n    event ERC20WithdrawConfirmed(bytes32,bool,uint256);\n    /// @notice event (0x1db696c9): The Treasury address is set\n    event TreasuryAddressSet(address,address);\n    /// @notice event (0x82b9d61d): ERC20 tokens deposit failed and refund issued to depositor\n    event ERC20DepositFailedAndRefunded(bytes32,bool,uint256);\n    /// @notice event (0x2ddb4d51): Worker is registered(true/false)\n    event WorkerRegistered(address,bool);\n\n    function getNonce() external view returns(uint256);\n    function totalSupplyAllChains() external view returns (uint256);\n    function totalSupply(uint256 chain_) external view returns (uint256);\n    function asset() external view returns (address);\n    function callbackHandler(uint256 chain_,\n                            bytes32 ack_,\n                            bool success_,\n                            uint256  retval_)\n        external returns(uint256);\n}"
    },
    "contracts/interface/dplat/IEnterprisePaymentPolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\ninterface IEnterprisePaymentPolicy {\n    function isUserOrDappEligibleForPayment(address user_, address dapp_, bytes4 functionSig_, uint256 amount_) external view returns(bool);\n    function updateEnterpriseEligibility(address user_, address dapp_, bytes4 functionSig_, uint256 amount_) external returns(bool);}"
    },
    "contracts/interface/dplat/IvERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title IvERC20\n * @dev Interface for a contract representing a variation of the ERC20 token.\n */\ninterface IvERC20 is IERC20 {\n    \n    /**\n     * @dev Burns a specified amount of tokens by transferring them to the specified address.\n     * @param to The address to which the tokens will be burned.\n     * @param amount The amount of tokens to be burned.\n     */\n    function burn(address to, uint256 amount) external returns(uint256);\n    \n    /**\n     * @dev Mints a specified amount of tokens and transfers them to the specified address.\n     * @param to The address to which the tokens will be minted and transferred.\n     * @param amount The amount of tokens to be minted.\n     */\n    function mint(address to, uint256 amount) external returns(uint256);\n}"
    },
    "contracts/interface/dplat/IZbyteDPlat.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\ninterface IZbyteDPlat {\n    function preExecute(address user_,\n                        address dapp_,\n                        bytes4 functionSig_,\n                        uint256 chargeEth_) external returns(address);\n\n    function postExecute(address payer_,\n                         bool executeResult_,\n                         uint256 reqValue_,\n                         uint256 gasConsumedEth_,\n                         uint256 preChargeEth_) external;\n}"
    },
    "contracts/interface/dplat/IZbytePriceFeeder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\n/// @title IZbytePriceFeeder\n/// @notice Interface for Zbyte price feeder, defining functions for gas cost conversion and retrieval.\ninterface IZbytePriceFeeder {\n    /// @notice Event(0xec97c145) the equivalent Zbyte price for native ETH is set.\n    event NativeEthEquivalentZbyteSet(uint256 nativeEthEquivalentZbyteInGwei);\n\n    /// @notice Event(0xd12b5bd7) the Zbyte price in Gwei is set.\n    event ZbytePriceInGweiSet(uint256 zbytePriceInGwei);\n\n    /// @notice Event(0xabd3562e) the burn rate is set.\n    event BurnRateInMillSet(uint256);\n\n    /// @notice Converts eth to equivalent Zbyte amount.\n    /// @dev Example:\n    /// Say, Native Eth Price = 1$\n    /// Zbyte Price = 2\n    /// nativeEthEquivalentZbyteInGwei = 50,000,000,000 Gwei (i.e. 1 Native Eth = 50 Zbyte)\n    /// ethAmount_  = 1,000,000,000,000,000,000 Wei (1 Native Eth)\n    /// zbyteAmount = (1,000,000,000,000,000,000 * 50,000,000,000) / 1,000,000,000\n    ///             = 50,000,000,000,000,000,000 Wei (50 ZBYT)\n    /// @param ethAmount_ Amount of eth.\n    /// @return Equivalent Amount of zbyte.\n    function convertEthToEquivalentZbyte(uint256 ethAmount_) external view returns (uint256);\n\n    /// @notice Converts price in millionths to Zbyte amount.\n    /// @dev Example:\n    /// Say, Unit Price = 1$\n    /// Zbyte Price = 2\n    /// So, zbytePriceEquivalentInGwei = 50,000,000,000 Gwei (i.e. 1 Unit = 50 Zbyte)\n    /// priceInMill_ = 20 Mill (i.e. (2 / 1000) Unit)\n    /// zbyteAmount = (20 * 50,000,000,000 * 1,000,000,000) / 1000\n    ///             = 1,000,000,000,000,000,000 Wei (1 ZBYT)\n    /// @param priceInMill_ Price in millionths.\n    /// @return Equivalent Zbyte amount.\n    function convertMillToZbyte(uint256 priceInMill_) external view returns (uint256);\n\n    /// @notice DPlat fee in terms of Zbyte\n    /// 1 Unit = 1000 Mill\n    /// @return DPlat fee\n    function getDPlatFeeInZbyte() external view returns(uint256);\n}"
    },
    "contracts/interface/relay/IRelayWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\n/// @title Relay wrapper interface (facilitates cross chain call during deposit/mint)\ninterface IRelayWrapper {\n\n    function performCrossChainCall(\n        uint256 relay_,\n        uint256 srcChain_,\n        uint256 destChain_,\n        address destContract_,\n        bytes calldata destCallData_,\n        bytes32 ack_,\n        address callbackContract_,\n        bytes calldata relayParams_\n    ) external payable returns (bool);\n\n    function isValidRelay(uint256 chainId, address relay_) external returns(bool);\n    function updatePayload(uint256 destChain_,\n                            address destContract_,\n                            bytes32 ack_,\n                            address callbackContract_,\n                            bytes calldata data_) external pure returns(bytes memory);\n}"
    },
    "contracts/relay/RelayWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"../interface/relay/IRelayWrapper.sol\";\nimport \"../utils/ZbyteContext.sol\";\n\n/// @title The Relay wrapper to facilitate ZBYT deposit/mint\n/// @dev The Relay wrapper to facilitate ZBYT deposit/mint\ncontract RelayWrapper is Ownable, Pausable, ZbyteContext, IRelayWrapper {\n    // errors\n    /// @notice error (0xeed987a0): The callback contract address is 0 but ack is set\n    error InvalidCallBackContract();\n    /// @notice error (0x089c2a3e): The relay contract address is not set for the given relay id\n    error RelayContractNotSet(uint256,address,address);\n    /// @notice error (0x5c87504d): Caller is not the registered escrow\n    error CallerNotEscrow(address,address);\n\n    // events\n    /// @notice error (0x14229a64): Address of escrow contract is set\n    event EscrowAddressSet(address);\n    /// @notice error (0xbe32fe92): Address of Relay is set for given chain id and relay id\n    event RelayAddressSet(uint256,uint256,address);\n\n    /// @notice mapping of chain id => relay id => relay address\n    /// @dev relay id is an identifier for relay (e.g., 0 -> zbyte relay, 1 -> axelar, etc)\n    mapping(uint256 => mapping (uint256 => address)) public relayContract;\n    /// @notice mapping of chain id => array of valid relay ids\n    mapping(uint256 => uint256[]) chainRelays;\n    /// @notice Registered escrow contract address\n    address public escrow;\n\n    /// @notice Relay Wrapper constructor\n    /// @param forwarder_ Forwarder contact address\n    constructor(address forwarder_) {\n        _setTrustedForwarder(forwarder_);\n    }\n\n     /// @notice Modifier to check if the caller is the registered escrow\n    modifier onlyEscrow {\n        if (_msgSender() != escrow) {\n            revert CallerNotEscrow(msg.sender,escrow);\n        }\n        _;\n    }\n\n    /// @notice Set the address of Escrow contract\n    /// @param escrow_ Escrow contract address\n    function setEscrowAddress(address escrow_) public onlyOwner {\n        if(escrow_ == address(0)) {\n            revert ZeroAddress();\n        }\n        escrow = escrow_;\n\n        emit EscrowAddressSet(escrow_);\n    }\n\n    /// @notice Set the address of Relay contract\n    /// @param chain_ Chain id for which the relay address is set\n    /// @param relayid_ Relay id for which relay address is set\n    /// @param relay_  Relay contract Address\n    /// @dev set the relay address to 0 to disable the relay\n    function setRelayAddress(uint256 chain_,\n        uint256 relayid_,\n        address relay_)\n        public onlyOwner {\n        if (relayContract[chain_][relayid_] == address(0)) {\n            chainRelays[chain_].push(relayid_);\n        }\n        relayContract[chain_][relayid_] = relay_;\n\n        emit RelayAddressSet(chain_,relayid_,relay_);\n    }\n\n    /// @notice Verify if given relay is a valid one for the given chain id\n    /// @param chain_ Chain id for which the relay address is set\n    /// @param relay_ Relay contract Address\n    function isValidRelay(uint256 chain_, address relay_) external view returns(bool) {\n        bool found = false;\n        for(uint256 i=0; i < chainRelays[chain_].length; i++) {\n            uint256 _relay = chainRelays[chain_][i];\n            if (relayContract[chain_][_relay] == relay_) {\n                return true;\n            }\n        }\n        return found;\n    }\n\n    /// @notice Initiate the cross chain call for deposit/mint\n    /// @param relayid_ Relay id that should be used for this call\n    /// @param srcChain_ Chain id of source chain\n    /// @param destChain_ Chain id of destination chain\n    /// @param destContract_ Address of contract to be called on destination chain\n    /// @param destCallData_ Calldata for the call on destination chain\n    /// @param ack_ Unique hash of the cross chain deposit/mint call\n    /// @param callbackContract_ Address of contract on source chain to handle callback\n    /// @param relayParams_ Additional data that can be sent to the relay\n    /// @dev This function can be called only the the registered escrow contract\n    function performCrossChainCall(\n        uint256 relayid_,\n        uint256 srcChain_,\n        uint256 destChain_,\n        address destContract_,\n        bytes calldata destCallData_,\n        bytes32 ack_,\n        address callbackContract_,\n        bytes calldata relayParams_\n    ) external payable onlyEscrow returns (bool) {\n        if ((uint256(ack_) != 0) && (callbackContract_ == address(0))) {\n            revert InvalidCallBackContract();\n        }\n        (relayParams_);\n        address _srcRelay = relayContract[srcChain_][relayid_]; // contract address on this chain\n        address _destRelay = relayContract[destChain_][relayid_]; // contract address on remote\n\n        if ((_srcRelay == address(0)) || (_destRelay == address(0))) {\n            revert RelayContractNotSet(relayid_,_srcRelay,_destRelay);\n        }\n\n        bytes memory _updatedPayLoad = updatePayload(destChain_,\n                                                    destContract_,\n                                                    ack_,\n                                                    callbackContract_,\n                                                    destCallData_);\n\n        (bool success, bytes memory data) = _srcRelay.call(\n            abi.encodeWithSignature(\"callRemote(uint256,address,bytes)\",\n                destChain_,_destRelay,_updatedPayLoad));\n        (data);\n        return success;\n    }\n\n    /// @notice Update the payload to include additional information\n    /// @param destChain_ Chain id of destination chain\n    /// @param destContract_ Address of contract to be called on destination chain\n    /// @param ack_ Unique hash of the cross chain deposit/mint call\n    /// @param callbackContract_ Address of contract on source chain to handle callback\n    /// @param data_ original payload\n    function updatePayload(uint256 destChain_,\n                            address destContract_,\n                            bytes32 ack_,\n                            address callbackContract_,\n                            bytes calldata data_)\n        public pure\n        returns(bytes memory) {\n        return abi.encode(destChain_,destContract_,ack_,callbackContract_,data_);\n    }\n\n    /// @notice ERC2771 _msgSender override\n    function _msgSender() internal view override(ZbyteContext,Context) returns (address sender) {\n        return ZbyteContext._msgSender();\n    }\n\n    /// @notice ERC2771 _msgData override\n    function _msgData() internal view override(ZbyteContext,Context) returns (bytes calldata) {\n        return ZbyteContext._msgData();\n    }\n}"
    },
    "contracts/relay/ZbyteRelay.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"../interface/relay/IRelayWrapper.sol\";\nimport \"../utils/ZbyteContext.sol\";\n\n/// @title The Zbyte Relay contract\n/// @dev The Zbyte Relay contract\ncontract ZbyteRelay is Ownable, ZbyteContext {\n    // errors\n    /// @notice error (0x0ca968d8): Caller is not an approved caller\n    error NotApproved(address);\n    /// @notice error (0x26fb3778): Caller is not the RelayWrapper or this contract\n    error NotRelayWrapperOrSelf(address,address);\n    /// @notice error (0xc16b00ce): Current chain id does not match with the one sent in payload\n    error InvalidChain(uint256,uint256);\n    /// @notice error (0x4a01d2ac): Invalid destination relay\n    error InvalidDestinationRelay(address,address);\n\n    // events\n    /// @notice event (0x9a3d7ba1): Received the request to perform a remote call\n    event RelayCallRemoteReceived(uint256,address,uint256,address,bytes);\n    /// @notice event (0xceeaa702): Executed the call request from a source chain\n    event RelayReceiveCallExecuted(bytes,bool,uint256);\n    /// @notice event (0x2658b600): Relay Wrapper address is set\n    event RelayWrapperSet(address);\n    /// @notice event (0xe89d9bcd): Approvee address is set\n    event RelayApproveeAdded(address);\n\n    /// @notice mapping of approved addresses.  Only these addresses can invoke the 'receiveCall'\n    mapping(address => bool) approved;\n    /// @notice Address of the RelayWrapper (on core)\n    IRelayWrapper public relayWrapper;\n\n    /// @notice Zbyte Relay constructor\n    /// @param forwarder_ Forwarder contact address\n    constructor(address forwarder_) {\n        _setTrustedForwarder(forwarder_);\n    }\n\n    /// @notice Modifier to check if the caller is approved or this contract\n    modifier onlyApprovedOrSelf {\n        if((approved[_msgSender()] != true) && (_msgSender() != address(this))) {\n             revert NotApproved(_msgSender());\n        }\n        _;\n    }\n\n    /// @notice Modifier to check if the caller is RelayWrapper or this contract\n    modifier onlyRelayWrapperOrSelf {\n        if ((_msgSender() != address(relayWrapper)) && (_msgSender() != address(this))) {\n            revert NotRelayWrapperOrSelf(_msgSender(),address(relayWrapper));\n        }\n        _;\n    }\n\n    /// @notice Set the RelayWrapper contract address\n    /// @param wrapper_ RelayWrapper contact address\n    function setRelayWrapper(address wrapper_) external onlyOwner {\n        if(wrapper_ == address(0)) {\n            revert ZeroAddress();\n        }\n\n        relayWrapper = IRelayWrapper(wrapper_);\n\n        emit RelayWrapperSet(wrapper_);\n    }\n\n    /// @notice Set the approvee address\n    /// @param approvee_ Address of the approvee\n    function addRelayApprovee(address approvee_) external onlyOwner {\n        if(approvee_ == address(0)) {\n            revert ZeroAddress();\n        }\n        approved[approvee_] = true;\n\n        emit RelayApproveeAdded(approvee_);\n    }\n\n    /// @notice Initiate the remote chain call\n    /// @param destChain_ Chain id of destination chain\n    /// @param destRelay_ Address of the trusted relay on destination chain\n    /// @param payload_ Payload to be used for the destination call\n    function callRemote(uint256 destChain_,\n                        address destRelay_,\n                        bytes memory payload_) // (destChain,destContract,ack,callbackContract,destCallData_)\n                        public\n                        payable\n                        onlyRelayWrapperOrSelf\n                        returns (bool) {\n        // initiate the remote call on source\n        (uint256 _destChain,,,,) =\n                abi.decode(payload_,(uint256,address,bytes32,address,bytes));\n        require(_destChain == destChain_, \"Invalid destination chain\");\n\n        bytes memory _updatedPayload = abi.encode(destRelay_, payload_);\n\n        // loop if dest == src\n        if (destChain_ == block.chainid) {\n            this.receiveCall(block.chainid,address(this),_updatedPayload);\n        }\n\n        emit RelayCallRemoteReceived(block.chainid,address(this),destChain_,destRelay_,_updatedPayload);\n        return true;\n    }\n\n    /// @notice Handle the call received from source chain\n    /// @param srcChain_ Chain id of source chain\n    /// @param srcRelay_ Address of the trusted relay on source chain\n    /// @param payload_ Payload to be used for the call on this chain\n    /// @dev Call can be made only by approved accounts or self\n    function receiveCall(uint256 srcChain_,\n                         address srcRelay_,\n                         bytes memory payload_) // (destRelay_,(destChain,destContract,ack,callbackContract,destCallData_))\n        onlyApprovedOrSelf\n        external\n        returns(bool) {\n        // receive the call on dest\n        (address _destRelay, bytes memory _callPayload) = abi.decode(payload_, (address, bytes));\n        (uint256 _destChain, address _destContract,\n         bytes32 _ack, address _callbackContract, bytes memory _data) = \n                abi.decode(_callPayload,(uint256,address,bytes32,address,bytes));\n        if(_destChain != block.chainid) {\n            revert InvalidChain(_destChain, block.chainid);\n        }\n        if(_destRelay != address(this)) {\n            revert InvalidDestinationRelay(_destRelay, address(this));\n        }\n\n        (bool success, bytes memory returnData) = _destContract.call(_data);\n        uint256 retval = abi.decode(returnData,(uint256));\n        \n        emit RelayReceiveCallExecuted(_callPayload,success,retval);\n\n\n        if ((_ack != bytes32(0)) && (_callbackContract != address(0))) {\n            bytes memory _updatedPayload = updatePayload(srcChain_,_callbackContract,\n                                bytes32(0),address(0),\n                               abi.encodeWithSignature(\"callbackHandler(uint256,bytes32,bool,uint256)\",\n                                _destChain,_ack,success,retval));\n            this.callRemote(srcChain_,srcRelay_,_updatedPayload);\n        }\n        return true;\n    }\n\n    /// @notice Update the payload to include additional information\n    /// @param destChain_ Chain id of destination chain\n    /// @param destContract_ Address of contract to be called on destination chain\n    /// @param ack_ Unique hash of the cross chain deposit/mint call\n    /// @param callbackContract_ Address of contract on source chain to handle callback\n    /// @param data_ original payload\n    function updatePayload(uint256 destChain_,\n                            address destContract_,\n                            bytes32 ack_,\n                            address callbackContract_,\n                            bytes memory data_)\n        public pure\n        returns(bytes memory) {\n        return abi.encode(destChain_,destContract_,ack_,callbackContract_,data_);\n    }\n\n    /// @notice ERC2771 _msgSender override\n    function _msgSender() internal view override(ZbyteContext,Context) returns (address sender) {\n        return ZbyteContext._msgSender();\n    }\n\n    /// @notice ERC2771 _msgData override\n    function _msgData() internal view override(ZbyteContext,Context) returns (bytes calldata) {\n        return ZbyteContext._msgData();\n    }\n}"
    },
    "contracts/samples/SampleDstoreDapp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\nimport \"../utils/ZbyteContext.sol\";\n\n/// @title Sample Data Storage Dapp\n/// @notice To prepare a contract for DPlat compatibility, users are required to derive from the abstract contract called ZbyteContext.\ncontract SampleDstoreDapp is  ZbyteContext {\n  event DStoreSet(address,uint256);\n\n  // address of plat and creator of contract\n  uint8 public storedValue;\n  address public storedBy;\n\n    constructor(address forwarder_) {\n      _setTrustedForwarder(forwarder_);\n    }\n    \n  function storeValue(uint8 _value) \n          public {\n\n    storedBy = _msgSender();\n    storedValue = _value;\n    emit DStoreSet(storedBy, storedValue);\n  }\n}"
    },
    "contracts/samples/ZbyteAirdropNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\nimport \"../utils/ZbyteContext.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Pausable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\n\n/// @title Zbyte's Airdrop NFT contract for DPLAT\ncontract ZbyteAirdropNFT is ZbyteContext, ERC721, ERC721URIStorage, ERC721Pausable, ERC721Enumerable {\n  using SafeERC20 for IERC20;\n\n  uint256 private _nextTokenId;\n  address public erc20Address;\n  uint256 erc20PerToken;\n  address distributor;\n  string uriBase;\n\n  event mintedForAirdrop(uint256,uint256);\n  event Redeemed(address,uint256);\n\n  error UserNumTokenRestriction(address,uint256);\n  error TokenDoesNotExist(uint256,address);\n\n  modifier onlyForwarder {\n    //require(isTrustedForwarder(msg.sender),\"Call not from Forwarder\");\n    _;\n  }\n\n  constructor(address forwarder_,\n              address erc20Address_,\n              uint256 erc20PerToken_,\n              address distributor_,\n              string memory baseUri_)\n              ERC721(\"DPLAT Airdrop\",\"DPLATAIR\") {\n    _setTrustedForwarder(forwarder_);\n    erc20Address = erc20Address_;\n    erc20PerToken = erc20PerToken_;\n    distributor = distributor_;\n    uriBase = baseUri_;\n    _nextTokenId = 1;\n  }\n  \n  function _baseURI() internal view override returns (string memory) {\n    return uriBase;\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n      public\n      view\n      override(ERC721, ERC721Enumerable)\n      returns (bool)\n  {\n      return super.supportsInterface(interfaceId);\n  }\n\n  function pause() public onlyOwner {\n    _pause();\n  }\n\n  function unpause() public onlyOwner {\n    _unpause();\n  }\n\n  function safeMint(address to, string memory uri) internal {\n    uint256 tokenId = _nextTokenId++;\n    _safeMint(to, tokenId);\n    _setTokenURI(tokenId, uri);\n  }\n\n  function _beforeTokenTransfer(address from,\n                                address to,\n                                uint256 tokenId)\n    internal onlyForwarder\n    override(ERC721, ERC721Pausable, ERC721Enumerable) {\n      ERC721Pausable._beforeTokenTransfer(from,to,tokenId);\n      ERC721Enumerable._beforeTokenTransfer(from,to,tokenId);\n  }\n\n  function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {\n    ERC721URIStorage._burn(tokenId);\n  }\n\n  /// @notice ERC2771 _msgSender override\n  function _msgSender() internal view override(ZbyteContext,Context) returns (address sender) {\n    return ZbyteContext._msgSender();\n  }\n\n  /// @notice ERC2771 _msgData override\n  function _msgData() internal view override(ZbyteContext,Context) returns (bytes calldata) {\n    return ZbyteContext._msgData();\n  }\n\n  function tokenURI(uint256 tokenId)\n      public\n      view\n      override(ERC721, ERC721URIStorage)\n      returns (string memory) {\n    return ERC721URIStorage.tokenURI(tokenId);\n  }\n\n  function mintForAirdrop(uint256 numTokens,string memory airdropUri)\n      public onlyOwner\n      onlyForwarder whenNotPaused {\n    uint256 startTokenId = _nextTokenId;\n    for(uint256 i=0 ; i<numTokens ; i++) {\n      safeMint(distributor,airdropUri);\n    }\n    emit mintedForAirdrop(numTokens,startTokenId);\n  }\n\n  function redeem(address receiver) public onlyForwarder {\n    address user = _msgSender();\n    if (receiver == address(0)) {\n      revert ZeroAddress();\n    }\n    uint256 numTokens = ERC721.balanceOf(user);\n    for (uint256 i=0 ; i < numTokens; i++) {\n      uint256 tokenId = tokenOfOwnerByIndex(user,i);\n      _burn(tokenId);\n    }\n    IERC20(erc20Address).safeTransfer(receiver,erc20PerToken*numTokens);\n\n    emit Redeemed(_msgSender(),numTokens);\n  }\n\n  function transferRemainingERC20(address recepient) public onlyOwner {\n    uint256 balance =  IERC20(erc20Address).balanceOf(address(this));\n    IERC20(erc20Address).safeTransfer(recepient,balance);\n  }\n}"
    },
    "contracts/samples/ZbyteDUSDT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ZbyteDUSDT is ERC20 {\n    constructor() ERC20(\"Dummy USDT Token\", \"DUSDT\") {\n        ERC20._mint(msg.sender, 6*10**9 * 10**decimals());\n    }\n}"
    },
    "contracts/utils/Auth.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n// Ref: https://github.com/transmissions11/solmate/tree/main/src/auth\n\npragma solidity ^0.8.9;\n\nimport \"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Auth controls\nabstract contract Auth {\n    /* \n        //in the contract that imports LibAuth\n        modifier requiresAuth {\n            require(LibAuth.isAuthorized(user,fnSig) == true)\n            _;\n        }\n        modifier requiresAuthOrOwner {\n            require(msg.sender == owner || LibAuth.isAuthorized(user,fnSig))\n            _;\n        }\n\n        transferOwnership() {\n            should call LibAuth.setOwner(newOwner);\n        }\n    */\n\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n    event PublicCapabilityUpdated(bytes4 indexed functionSig, bool enabled);\n    event RoleCapabilityUpdated(uint8 indexed role, bytes4 indexed functionSig, bool enabled);\n\n    struct DiamondStorage {\n        mapping(address => bytes32) getUserRoles;\n        mapping(bytes4 => bool) isCapabilityPublic;\n        mapping(bytes4 => bytes32) getRolesWithCapability;\n    }\n\n    function diamondStorage() internal pure returns(DiamondStorage storage ds) {\n        bytes32 storagePosition = keccak256(\"diamond.storage.LibAuth.v1\");\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n\n    function getOwner() public virtual returns(address) {\n    }\n\n    function doesUserHaveRole(address user, uint8 role) public view returns (bool) {\n        DiamondStorage storage ds = diamondStorage();\n        return (uint256(ds.getUserRoles[user]) >> role) & 1 != 0;\n    }\n\n    function doesRoleHaveCapability(\n        uint8 role,\n        bytes4 functionSig\n    ) public view returns (bool) {\n        DiamondStorage storage ds = diamondStorage();\n        return (uint256(ds.getRolesWithCapability[functionSig]) >> role) & 1 != 0;\n    }\n\n    function canCall(\n        address user,\n        bytes4 functionSig\n    ) public view returns (bool) {\n        DiamondStorage storage ds = diamondStorage();\n        return\n            ds.isCapabilityPublic[functionSig] ||\n            bytes32(0) != ds.getUserRoles[user] & ds.getRolesWithCapability[functionSig];\n    }\n\n    function isAuthorized(address user, bytes4 functionSig) internal view returns (bool) {\n        return canCall(user, functionSig);\n    }\n\n    function isAuthorizedOrOwner(address user, bytes4 functionSig) internal returns (bool) {\n        return canCall(user, functionSig) || user == getOwner();\n    }\n\n    modifier requiresAuth {\n        require(isAuthorized(msg.sender, msg.sig), \"UNAUTHORIZED\");\n        _;\n    }\n\n    modifier requiresAuthOrOwner {\n        require(isAuthorizedOrOwner(msg.sender, msg.sig), \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    function setPublicCapability(\n        bytes4 functionSig,\n        bool enabled\n    ) public requiresAuthOrOwner {\n        DiamondStorage storage ds = diamondStorage();\n        ds.isCapabilityPublic[functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(functionSig, enabled);\n    }\n\n    function setRoleCapability(\n        uint8 role,\n        bytes4 functionSig,\n        bool enabled\n    ) public requiresAuthOrOwner {\n        DiamondStorage storage ds = diamondStorage();\n        if (enabled) {\n            ds.getRolesWithCapability[functionSig] |= bytes32(1 << role);\n        } else {\n            ds.getRolesWithCapability[functionSig] &= ~bytes32(1 << role);\n        }\n\n        emit RoleCapabilityUpdated(role, functionSig, enabled);\n    }\n\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) public requiresAuthOrOwner {\n        DiamondStorage storage ds = diamondStorage();\n        if (enabled) {\n            ds.getUserRoles[user] |= bytes32(1 << role);\n        } else {\n            ds.getUserRoles[user] &= ~bytes32(1 << role);\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n}\n\nabstract contract AuthDiamond is Auth {\n    function getOwner() public virtual override returns(address) {\n        return LibDiamond.diamondStorage().contractOwner;\n    }\n}\n\nabstract contract AuthSimple is Auth, Ownable {\n    function getOwner() public virtual override returns(address) {\n        return owner();\n    }\n}"
    },
    "contracts/utils/LibCommonErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\nlibrary LibCommonErrors {\n    error ZeroAddress();\n    error NotOwner();\n    error Unauthorized();\n    error ArraySizeMismatched(uint256,uint256);\n}"
    },
    "contracts/utils/LibZbyteForwarderFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\nimport \"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\";\n\n/// @notice The Zbyte Forwarder Facet\n/// @dev The Zbyte Forwarder Facet\nlibrary LibZbyteForwarderFacet {\n\n    /// @notice Diamond storage for DPlat registration struct\n    struct DiamondStorage {\n        address trustedForwarder;\n    }\n\n    /// @notice Retrieves the DiamondStorage struct for the library.\n    /// @dev trustedForwarder: Address of the trusted forwarder\n    function diamondStorage() internal pure returns(DiamondStorage storage ds) {\n        bytes32 storagePosition = keccak256(\"diamond.storage.LibZbyteForwarderFacet.v1\");\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n\n    /// @notice Sets the address of trusted forwarder\n    /// @param forwarder_: Address of the trusted forwarder\n    function _setTrustedForwarder(address forwarder_) internal {\n        LibDiamond.enforceIsContractOwner();\n        DiamondStorage storage dsc = diamondStorage();\n        dsc.trustedForwarder = forwarder_;\n    }\n\n    /// @notice Gets the address of trusted forwarder\n    function _getTrustedForwarder() internal view returns(address) {\n        DiamondStorage storage dsc = diamondStorage();\n        return dsc.trustedForwarder;\n    }\n\n    /// @notice Checks if the given forwarder is the trusted forwarder\n    /// @param forwarder_: Address of the forwarder to check\n    function isTrustedForwarder(address forwarder_) internal view returns(bool) {\n        DiamondStorage storage dsc = diamondStorage();\n        return forwarder_ == dsc.trustedForwarder;\n    }\n}"
    },
    "contracts/utils/ZbyteContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title The ZBYT ERC20 contract\n/// @dev ERC2771Context with a function to set forwarder\nabstract contract ZbyteContext is Context, Ownable {\n    // errors\n    /// @notice error (0xbf064619): Contract cannot receive ether\n    error CannotSendEther();\n    /// @notice error (0xd92e233d): Address is address(0)\n    error ZeroAddress();\n    /// @notice error(): Value sent is 0\n    error ZeroValue();\n\n    // events\n    /// @notice event (0x94aed472): Forwarder address is changed\n    event ForwarderSet(address,address);\n\n    // Trusted forwarder address\n    address private trustedForwarder;\n\n    // /// @notice ZbyteContext constructor\n    // /// @param forwarder_ Forwarder contact address\n    // constructor(address forwarder_) {\n    //     _setTrustedForwarder(forwarder_);\n    // }\n\n    /// @notice Check if the given address is the trusted forwarder\n    /// @param forwarder_ Address to check\n    /// @return true if forwarder_ is trusted forwarder\n    function isTrustedForwarder(address forwarder_) public view virtual returns (bool) {\n        return forwarder_ == trustedForwarder;\n    }\n\n    /// @notice Set a trusted forwarder address\n    /// @param forwarder_ Trusted forwarder address\n    /// @dev emits ForwarderSet on success\n    function _setTrustedForwarder(address forwarder_) internal {\n        if (forwarder_ == address(0)) {\n            revert ZeroAddress();\n        }\n        address oldForwarder = trustedForwarder;\n        trustedForwarder = forwarder_;\n\n        emit ForwarderSet(oldForwarder,forwarder_);\n    }\n\n    /// @notice Set the forwarder contract address\n    /// @param forwarder_ Frwarder conract address\n    /// @dev onlyOwner can call\n    function setTrustedForwarder(address forwarder_) public onlyOwner {\n        _setTrustedForwarder(forwarder_);\n    }\n\n    /// @notice Get the trusted forwarder address\n    function _getTrustedForwarder() internal view returns(address){\n        return trustedForwarder;\n    }\n\n    /// @notice Extract true caller if called via trusted forwarder\n    function _msgSender() internal view virtual override returns (address sender) {\n        if (isTrustedForwarder(msg.sender)) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    /// @notice Extract data if called via trusted forwarder\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        if (isTrustedForwarder(msg.sender)) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return super._msgData();\n        }\n    }\n}\n"
    },
    "contracts/utils/ZbyteContextDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\nimport \"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\";\nimport \"./LibZbyteForwarderFacet.sol\";\n\ncontract ZbyteContextDiamond {\n    /// @notice error (0x5ac85bab): Caller is not a forwarder\n    error NotAForwarder();\n\n    /// @notice modifier to enforce that the caller is the owner\n    modifier onlyOwner {\n        LibDiamond.enforceIsContractOwner();\n        _;\n    }\n\n    /// @notice modifier to enforce that the caller is the forwarder\n    modifier onlyForwarder {\n        if(LibZbyteForwarderFacet.isTrustedForwarder(_msgSender())) revert NotAForwarder();\n        _;\n    }\n\n    /// @notice Extract true caller if called via trusted forwarder\n    function _msgSender() internal view returns (address ret) {\n        if (msg.data.length >= 20 && LibZbyteForwarderFacet.isTrustedForwarder(msg.sender)) {\n            // At this point we know that the sender is a trusted forwarder,\n            // so we trust that the last bytes of msg.data are the verified sender address.\n            // extract sender address from the end of msg.data\n            assembly {\n                ret := shr(96,calldataload(sub(calldatasize(),20)))\n            }\n        } else {\n            ret = msg.sender;\n        }\n    }\n\n    /// @notice Extract data if called via trusted forwarder\n    function _msgData() internal view returns (bytes calldata ret) {\n        if (msg.data.length >= 20 && LibZbyteForwarderFacet.isTrustedForwarder(msg.sender)) {\n            return msg.data[0:msg.data.length-20];\n        } else {\n            return msg.data;\n        }\n    }\n}"
    },
    "contracts/utils/ZbyteForwarderFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// --.. -... -.-- - . \n//     \n//  \n//              \n//                \n//             \n//              \n// --.. -... -.-- - . \n\npragma solidity ^0.8.9;\n\nimport \"hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol\";\nimport \"./LibZbyteForwarderFacet.sol\";\n\ncontract ZbyteForwarderFacet {\n    // events\n    /// @notice event (0x94aed472): Forwarder address is changed\n    event ForwarderSet(address);\n\n    /// @notice Set the address of trusted forwarder\n    /// @param forwarder_ Address of the trusted forwarder\n    function setForwarder(address forwarder_) public {\n        LibZbyteForwarderFacet._setTrustedForwarder(forwarder_);\n        emit ForwarderSet(forwarder_);\n    }\n\n    /// @notice Get the address of trusted forwarder\n    function getTrustedForwarder() public view returns(address) {\n        return LibZbyteForwarderFacet._getTrustedForwarder();\n    }\n}"
    },
    "hardhat-deploy/solc_0.8/diamond/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();        \n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);            \n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }    \n\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n        } else {\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}